<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/idea32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/idea16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="进程概述程序是包含一系列信息的文件，这些信息描述了如何在运行时创建一个进程：  二进制格式标识：每个程序文件都包含用于描述可执行文件格式的元信息。内核利用此信息来解释文件中的其他信息。（ELF可执行连接格式） 机器语言指令：对程序算法进行编码。 程序入口地址：标识程序开始执行时的起始指令位置。">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux多进程开发笔记">
<meta property="og:url" content="http://yoursite.com/2021/04/17/Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="MoChen&#39;s">
<meta property="og:description" content="进程概述程序是包含一系列信息的文件，这些信息描述了如何在运行时创建一个进程：  二进制格式标识：每个程序文件都包含用于描述可执行文件格式的元信息。内核利用此信息来解释文件中的其他信息。（ELF可执行连接格式） 机器语言指令：对程序算法进行编码。 程序入口地址：标识程序开始执行时的起始指令位置。">
<meta property="og:locale">
<meta property="og:image" content="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/de832ea0-8b89-418d-a1f2-92be44a500fa/Untitled.png">
<meta property="og:image" content="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1fdc197e-1bfb-4c58-a7b8-c1998c3c7374/Untitled.png">
<meta property="og:image" content="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9dc011a5-5e65-46d6-9b0b-d1731809f1b3/Untitled.png">
<meta property="og:image" content="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f58c1173-afe4-4057-9771-f116833388ca/Untitled.png">
<meta property="og:image" content="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0e119e93-68b0-43bb-9248-7bb7f097c537/Untitled.png">
<meta property="og:image" content="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f930a6c0-dfc7-4478-b7bf-85d0053f627b/Untitled.png">
<meta property="og:image" content="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/09a88cdd-814c-4091-8c37-0fbbb1d361e5/Untitled.png">
<meta property="article:published_time" content="2021-04-17T19:33:42.000Z">
<meta property="article:modified_time" content="2021-04-17T19:36:12.128Z">
<meta property="article:author" content="MoChen">
<meta property="article:tag" content="Linux，多进程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/de832ea0-8b89-418d-a1f2-92be44a500fa/Untitled.png">

<link rel="canonical" href="http://yoursite.com/2021/04/17/Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-Hans'
  };
</script>

  <title>Linux多进程开发笔记 | MoChen's</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">MoChen's</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/04/17/Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://hexo-blog-1254337849.cos.na-ashburn.myqcloud.com/WechatIMG93.jpeg">
      <meta itemprop="name" content="MoChen">
      <meta itemprop="description" content="临渊羡鱼，不如退而结网">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MoChen's">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Linux多进程开发笔记
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-04-17 20:33:42" itemprop="dateCreated datePublished" datetime="2021-04-17T20:33:42+01:00">2021-04-17</time>
            </span>

          
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="进程概述"><a href="#进程概述" class="headerlink" title="进程概述"></a>进程概述</h1><p>程序是包含一系列信息的文件，这些信息描述了如何在运行时创建一个进程：</p>
<ul>
<li>二进制格式标识：每个程序文件都包含用于描述可执行文件格式的元信息。内核利用此信息来解释文件中的其他信息。（ELF可执行连接格式）</li>
<li>机器语言指令：对程序算法进行编码。</li>
<li>程序入口地址：标识程序开始执行时的起始指令位置。</li>
</ul>
<a id="more"></a>

<ul>
<li>数据：程序文件包含的变量初始值和程序使用的字面量值（比如字符串）。</li>
<li>符号表及重定位表：描述程序中函数和变量的位置及名称。这些表格有多重用途，其中包括调试和运行时的符号解析（动态链接）。</li>
<li>共享库和动态链接信息：程序文件所包含的一些字段，列出了程序运行时需要使用的共享库，以及加载共享库的动态连接器的路径名。</li>
<li>其他信息：程序文件还包含许多其他信息，用以描述如何创建进程。</li>
</ul>
<p>进程是正在运行的程序的实例。是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元。</p>
<p>可以用一个程序来创建多个进程，进程是由内核定义的抽象实体，并为该实体分配用以执行程序的各项系统资源。从内核的角度看，进程由用户内存空间和一系列内核数据结构组成，其中用户内存空间包含了程序代码及代码所使用的变量，而内核数据结构则用于维护进程状态信息。记录在内核数据结构中的信息包括许多与进程相关的标识号（IDs）、虚拟内存表、打开文件的描述符表、信号传递及处理的有关信息、进程资源使用及限制、当前工作目录和大量的其他信息。</p>
<ul>
<li>对于一个单 CPU 系统来说，程序同时处于运行状态只是一种宏观上的概念，他们虽然都已经开始运行，但就微观而言，任意时刻，CPU 上运行的程序只有一个。</li>
</ul>
<h2 id="时间片"><a href="#时间片" class="headerlink" title="时间片"></a>时间片</h2><ul>
<li>时间片（timeslice）又称为“量子（quantum）”或“处理器片（processor slice）”是操作系统分配给每个正在运行的进程微观上的一段 CPU 时间。事实上，虽然一台计算机通常可能有多个 CPU，但是同一个 CPU 永远不可能真正地同时运行多个任务。在只考虑一个 CPU 的情况下，这些进程“看起来像”同时运行的，实则是轮番穿插地运行，由于时间片通常很短（在 Linux 上为 5ms－800ms），用户不会感觉到。</li>
<li>时间片由操作系统内核的调度程序分配给每个进程。首先，内核会给每个进程分配相等的初始时间片，然后每个进程轮番地执行相应的时间，当所有进程都处于时间片耗尽的状态时，内核会重新为每个进程计算并分配时间片，如此往复。</li>
<li>并行（parallel）：指在同一时刻，有多条指令在多个处理器上同时执行。</li>
<li>并发（concurrency）：指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行。</li>
</ul>
<h2 id="进程控制块（PCB）"><a href="#进程控制块（PCB）" class="headerlink" title="进程控制块（PCB）"></a>进程控制块（PCB）</h2><ul>
<li>为了管理进程，内核必须对每个进程所做的事情进行清楚的描述。内核为每个进程分配一个 PCB(Processing Control Block)进程控制块，维护进程相关的信息，Linux 内核的进程控制块是 task_struct 结构体。</li>
<li>在 /usr/src/linux-headers-xxx/include/linux/sched.h 文件中可以查看 struct task_struct 结构体定义。其内部成员有很多，我们只需要掌握以下部分即可：<ul>
<li>进程id：系统中每个进程有唯一的 id，用 pid_t 类型表示，其实就是一个非负整数</li>
<li>进程的状态：有就绪、运行、挂起、停止等状态</li>
<li>进程切换时需要保存和恢复的一些CPU寄存器</li>
<li>描述虚拟地址空间的信息</li>
<li>描述控制终端的信息</li>
</ul>
</li>
</ul>
<hr>
<h1 id="进程状态转换"><a href="#进程状态转换" class="headerlink" title="进程状态转换"></a>进程状态转换</h1><p>进程状态反映进程执行过程的变化。这些状态随着进程的执行和外界条件的变化而转换。</p>
<p>在三态模型中，进程状态分为三个基本状态，即就绪态，运行态，阻塞态。在五态模型</p>
<p>中，进程分为新建态、就绪态，运行态，阻塞态，终止态。</p>
<ul>
<li>运行态：进程占有处理器正在运行</li>
<li>就绪态：进程具备运行条件，等待系统分配处理器以便运行。当进程已分配到除CPU以外的所有必要资源后，只要再获得CPU，便可立即执行。在一个系统中处于就绪状态的进程可能有多个，通常将它们排成一个队列，称为就绪队列</li>
<li>阻塞态：又称为等待(wait)态或睡眠(sleep)态，指进程不具备运行条件，正在等待某个事件的完成</li>
<li>新建态：进程刚被创建时的状态，尚未进入就绪队列</li>
<li>终止态：进程完成任务到达正常结束点，或出现无法克服的错误而异常终止，或被操作系统及有终止权的进程所终止时所处的状态。进入终止态的进程以后不再执行，但依然保留在操作系统中等待善后。一旦其他进程完成了对终止态进程的信息抽取之后，操作系统将删除该进程。</li>
</ul>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/de832ea0-8b89-418d-a1f2-92be44a500fa/Untitled.png" alt="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/de832ea0-8b89-418d-a1f2-92be44a500fa/Untitled.png"></p>
<h2 id="进程相关命令"><a href="#进程相关命令" class="headerlink" title="进程相关命令"></a>进程相关命令</h2><ul>
<li><p>查看进程</p>
<p>ps aux/ajx</p>
<p>a：显示终端上的所有进程，包括其他用户的进程</p>
<p>u：显示进程的详细信息</p>
<p>x：显示没有控制终端的进程</p>
<p>j：列出与作业控制相关的信息</p>
</li>
<li><p>STAT参数意义：</p>
<p>D 不可中断 Uninterruptible（usually IO）</p>
<p>R 正在运行，或在队列中的进程</p>
<p>S(大写) 处于休眠状态</p>
<p>T 停止或被追踪</p>
<p>Z 僵尸进程</p>
<p>W 进入内存交换（从内核2.6开始无效）</p>
<p>X 死掉的进程</p>
<p>&lt; 高优先级</p>
<p>N 低优先级</p>
<p>s 包含子进程</p>
<ul>
<li>位于前台的进程组</li>
</ul>
</li>
<li><p>实时显示进程动态</p>
<p>top</p>
<p>可以在使用 top 命令时加上 -d 来指定显示信息更新的时间间隔，在 top 命令执行后，可以按以下按键对显示的结果进行排序：</p>
<ul>
<li>M 根据内存使用量排序</li>
<li>P 根据 CPU 占有率排序</li>
<li>T 根据进程运行时间长短排序</li>
<li>U 根据用户名来筛选进程</li>
<li>K 输入指定的 PID 杀死进程</li>
</ul>
</li>
<li><p>杀死进程</p>
<p>kill [-signal] pid</p>
<p>kill –l 列出所有信号</p>
<p>kill –SIGKILL 进程ID</p>
<p>kill -9 进程ID</p>
<p>killall name 根据进程名杀死进程</p>
</li>
</ul>
<h2 id="进程号和相关函数"><a href="#进程号和相关函数" class="headerlink" title="进程号和相关函数"></a>进程号和相关函数</h2><ul>
<li>每个进程都由进程号来标识，其类型为 pid_t（整型），进程号的范围：0～32767。进程号总是唯一的，但可以重用。当一个进程终止后，其进程号就可以再次使用。</li>
<li>任何进程（除 init 进程）都是由另一个进程创建，该进程称为被创建进程的父进程，对应的进程号称为父进程号（PPID）。</li>
<li>进程组是一个或多个进程的集合。他们之间相互关联，进程组可以接收同一终端的各种信号，关联的进程有一个进程组号（PGID）。默认情况下，当前的进程号会当做当前的进程组号。</li>
<li>进程号和进程组相关函数：<ul>
<li>pid_t getpid(void); // 当前进程id</li>
<li>pid_t getppid(void); // 父进程id</li>
<li>pid_t getpgid(pid_t pid); // 组进程id</li>
</ul>
</li>
</ul>
<hr>
<h1 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h1><p>系统允许一个进程创建新进程，新进程即为子进程，子进程还可以创建新的子进程，形成进程树结构模型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys&#x2F;types.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">pid_t fork(void);</span><br><span class="line">    函数的作用：用于创建子进程。</span><br><span class="line">    返回值：</span><br><span class="line">        fork()的返回值会返回两次。一次是在父进程中，一次是在子进程中。</span><br><span class="line">        在父进程中返回创建的子进程的ID,</span><br><span class="line">        在子进程中返回0</span><br><span class="line">        如何区分父进程和子进程：通过fork的返回值。</span><br><span class="line">        在父进程中返回-1，表示创建子进程失败，并且设置errno</span><br><span class="line"></span><br><span class="line">    父子进程之间的关系：</span><br><span class="line">    区别：</span><br><span class="line">        1.fork()函数的返回值不同</span><br><span class="line">            父进程中: &gt;0 返回的子进程的ID</span><br><span class="line">            子进程中: &#x3D;0</span><br><span class="line">        2.pcb中的一些数据</span><br><span class="line">            当前的进程的id pid</span><br><span class="line">            当前的进程的父进程的id ppid</span><br><span class="line">            信号集</span><br><span class="line"></span><br><span class="line">    共同点：</span><br><span class="line">        某些状态下：子进程刚被创建出来，还没有执行任何的写数据的操作</span><br><span class="line">            - 用户区的数据</span><br><span class="line">            - 文件描述符表</span><br><span class="line"></span><br><span class="line">    父子进程对变量是不是共享的？</span><br><span class="line">        - 刚开始的时候，是一样的，共享的。如果修改了数据，不共享了。</span><br><span class="line">        - 读时共享（子进程被创建，两个进程没有做任何的写的操作），写时拷贝。</span><br></pre></td></tr></table></figure>

<p>使用 GDB 调试的时候，GDB 默认只能跟踪一个进程，可以在 fork 函数调用之前，通过指令设置 GDB 调试工具跟踪父进程或者是跟踪子进程，默认跟踪父进程。</p>
<ul>
<li><p>设置调试父进程或者子进程：set follow-fork-mode [parent（默认）| child]</p>
</li>
<li><p>设置调试模式：set detach-on-fork [on | off]</p>
<p>默认为 on，表示调试当前进程的时候，其它的进程继续运行，如果为 off，调试当前进程的时候，其它进程被 GDB 挂起。</p>
</li>
<li><p>查看调试的进程：info inferiors</p>
</li>
<li><p>切换当前调试的进程：inferior id</p>
</li>
<li><p>使进程脱离 GDB 调试：detach inferiors id</p>
</li>
</ul>
<hr>
<h1 id="exec函数族"><a href="#exec函数族" class="headerlink" title="exec函数族"></a>exec函数族</h1><p>exec 函数族的作用是根据指定的文件名找到可执行文件，并用它来取代调用进程的内容，换句话说，就是在调用进程内部执行一个可执行文件。</p>
<p>exec 函数族的函数执行成功后不会返回，因为调用进程的实体，包括代码段，数据段和堆栈等都已经被新的内容取代，只留下进程 ID 等一些表面上的信息仍保持原样，颇有些神似“三十六计”中的“金蝉脱壳”。看上去还是旧的躯壳，却已经注入了新的灵魂。只有调用失败了，它们才会返回 -1，从原程序的调用点接着往下执行。</p>
<h2 id="exec函数族-1"><a href="#exec函数族-1" class="headerlink" title="exec函数族"></a>exec函数族</h2><ul>
<li><p>int execl(const char *path, const char <em>arg, …/</em> (char *) NULL */);</p>
</li>
<li><p>int execlp(const char *file, const char <em>arg, … /</em> (char *) NULL */);</p>
</li>
<li><p>int execle(const char *path, const char <em>arg, …/</em>, (char *) NULL, char *const envp[] */);</p>
</li>
<li><p>int execv(const char *path, char *const argv[]);</p>
</li>
<li><p>int execvp(const char *file, char *const argv[]);</p>
</li>
<li><p>int execvpe(const char *file, char *const argv[], char *const envp[]);</p>
</li>
<li><p>int execve(const char *filename, char *const argv[], char *const envp[]);</p>
<p>l(list) 参数地址列表，以空指针结尾</p>
<p>v(vector) 存有各参数地址的指针数组的地址</p>
<p>p(path) 按 PATH 环境变量指定的目录搜索可执行文件</p>
<p>e(environment) 存有环境变量字符串地址的指针数组的地址</p>
</li>
</ul>
<h3 id="execl"><a href="#execl" class="headerlink" title="execl"></a>execl</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int execl(const char *path, const char *arg, ...);</span><br><span class="line">	- 参数：</span><br><span class="line">	- path:需要指定的执行的文件的路径或者名称</span><br><span class="line">			a.out &#x2F;home&#x2F;nowcoder&#x2F;a.out 推荐使用绝对路径</span><br><span class="line">			.&#x2F;a.out hello world        </span><br><span class="line">	</span><br><span class="line">	- arg:是执行可执行文件所需要的参数列表</span><br><span class="line">	  第一个参数一般没有什么作用，为了方便，一般写的是执行的程序的名称</span><br><span class="line">    从第二个参数开始往后，就是程序执行所需要的的参数列表。</span><br><span class="line">    参数最后需要以NULL结束（哨兵）</span><br><span class="line"></span><br><span class="line">  - 返回值：</span><br><span class="line">	  只有当调用失败，才会有返回值，返回-1，并且设置errno</span><br><span class="line">    如果调用成功，没有返回值。</span><br></pre></td></tr></table></figure>

<h3 id="execlp"><a href="#execlp" class="headerlink" title="execlp"></a>execlp</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int execlp(const char *file, const char *arg, ... );</span><br><span class="line">    - 会到环境变量中查找指定的可执行文件，如果找到了就执行，找不到就执行不成功。</span><br><span class="line">    - 参数：</span><br><span class="line">        - file:需要执行的可执行文件的文件名</span><br><span class="line">            a.out</span><br><span class="line">            ps</span><br><span class="line"></span><br><span class="line">        - arg:是执行可执行文件所需要的参数列表</span><br><span class="line">            第一个参数一般没有什么作用，为了方便，一般写的是执行的程序的名称</span><br><span class="line">            从第二个参数开始往后，就是程序执行所需要的的参数列表。</span><br><span class="line">            参数最后需要以NULL结束（哨兵）</span><br><span class="line"></span><br><span class="line">    - 返回值：</span><br><span class="line">        只有当调用失败，才会有返回值，返回-1，并且设置errno</span><br><span class="line">        如果调用成功，没有返回值。</span><br><span class="line"></span><br><span class="line">int execv(const char *path, char *const argv[]);</span><br><span class="line">argv是需要的参数的一个字符串数组</span><br><span class="line">char * argv[] &#x3D; &#123;&quot;ps&quot;, &quot;aux&quot;, NULL&#125;;</span><br><span class="line">execv(&quot;&#x2F;bin&#x2F;ps&quot;, argv);</span><br><span class="line"></span><br><span class="line">int execve(const char *filename, char *const argv[], char *const envp[]);</span><br><span class="line">char * envp[] &#x3D; &#123;&quot;&#x2F;home&#x2F;nowcoder&quot;, &quot;&#x2F;home&#x2F;bbb&quot;, &quot;&#x2F;home&#x2F;aaa&quot;&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="进程退出、孤儿进程、僵尸进程"><a href="#进程退出、孤儿进程、僵尸进程" class="headerlink" title="进程退出、孤儿进程、僵尸进程"></a>进程退出、孤儿进程、僵尸进程</h1><h2 id="进程退出"><a href="#进程退出" class="headerlink" title="进程退出"></a>进程退出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt; &#x2F;&#x2F; C程序函数</span><br><span class="line">void exit(int status);</span><br><span class="line"></span><br><span class="line">#include &lt;unistd.h&gt; &#x2F;&#x2F;系统调用</span><br><span class="line">void _exit(int status);</span><br><span class="line"></span><br><span class="line">status参数：是进程退出时的一个状态信息。父进程回收子进程资源的时候可以获取到。</span><br></pre></td></tr></table></figure>

<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1fdc197e-1bfb-4c58-a7b8-c1998c3c7374/Untitled.png" alt="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1fdc197e-1bfb-4c58-a7b8-c1998c3c7374/Untitled.png"></p>
<h2 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h2><ul>
<li>父进程运行结束，但子进程还在运行（未运行结束），这样的子进程就称为孤儿进程（Orphan Process）。</li>
<li>每当出现一个孤儿进程的时候，内核就把孤儿进程的父进程设置为 init ，而 init进程会循环地 wait() 它的已经退出的子进程。这样，当一个孤儿进程凄凉地结束了其生命周期的时候，init 进程就会代表党和政府出面处理它的一切善后工作。</li>
<li>因此孤儿进程并不会有什么危害。</li>
</ul>
<h2 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h2><ul>
<li>每个进程结束之后, 都会释放自己地址空间中的用户区数据，内核区的 PCB 没有办法自己释放掉，需要父进程去释放。</li>
<li>进程终止时，父进程尚未回收，子进程残留资源（PCB）存放于内核中，变成僵尸（Zombie）进程。</li>
<li>僵尸进程不能被 kill -9 杀死，这样就会导致一个问题，如果父进程不调用 wait()或 waitpid() 的话，那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程，此即为僵尸进程的危害，应当避免。</li>
</ul>
<h2 id="进程回收"><a href="#进程回收" class="headerlink" title="进程回收"></a>进程回收</h2><ul>
<li>在每个进程退出的时候，内核释放该进程所有的资源、包括打开的文件、占用的内存等。但是仍然为其保留一定的信息，这些信息主要主要指进程控制块PCB的信息（包括进程号、退出状态、运行时间等）。</li>
<li>父进程可以通过调用wait或waitpid得到它的退出状态同时彻底清除掉这个进程。</li>
<li>wait() 和 waitpid() 函数的功能一样，区别在于，wait() 函数会阻塞，waitpid() 可以设置不阻塞，waitpid() 还可以指定等待哪个子进程结束。</li>
<li>注意：一次wait或waitpid调用只能清理一个子进程，清理多个子进程应使用循环。</li>
</ul>
<h2 id="退出信息相关宏函数"><a href="#退出信息相关宏函数" class="headerlink" title="退出信息相关宏函数"></a>退出信息相关宏函数</h2><ul>
<li>WIFEXITED(status) 非0，进程正常退出</li>
<li>WEXITSTATUS(status) 如果上宏为真，获取进程退出的状态（exit的参数）</li>
<li>WIFSIGNALED(status) 非0，进程异常终止</li>
<li>WTERMSIG(status) 如果上宏为真，获取使进程终止的信号编号</li>
<li>WIFSTOPPED(status) 非0，进程处于暂停状态</li>
<li>WSTOPSIG(status) 如果上宏为真，获取使进程暂停的信号的编号</li>
<li>WIFCONTINUED(status) 非0，进程暂停后已经继续运行</li>
</ul>
<h2 id="wait和waitpid函数"><a href="#wait和waitpid函数" class="headerlink" title="wait和waitpid函数"></a>wait和waitpid函数</h2><h3 id="wait函数"><a href="#wait函数" class="headerlink" title="wait函数"></a>wait函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys&#x2F;types.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;wait.h&gt;</span><br><span class="line">pid_t wait(int *wstatus);</span><br><span class="line">    功能：等待任意一个子进程结束，如果任意一个子进程结束了，次函数会回收子进程的资源。</span><br><span class="line">    参数：int *wstatus</span><br><span class="line">        进程退出时的状态信息，传入的是一个int类型的地址，传出参数。</span><br><span class="line">    返回值：</span><br><span class="line">        - 成功：返回被回收的子进程的id</span><br><span class="line">        - 失败：-1 (所有的子进程都结束，调用函数失败)</span><br><span class="line"></span><br><span class="line">调用wait函数的进程会被挂起（阻塞），直到它的一个子进程退出或者收到一个不能被忽略的信号时才被唤醒（相当于继续往下执行）</span><br><span class="line">如果没有子进程了，函数立刻返回，返回-1；如果子进程都已经结束了，也会立即返回，返回-1.</span><br></pre></td></tr></table></figure>

<h3 id="waitpid函数"><a href="#waitpid函数" class="headerlink" title="waitpid函数"></a>waitpid函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys&#x2F;types.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;wait.h&gt;</span><br><span class="line">pid_t waitpid(pid_t pid, int *wstatus, int options);</span><br><span class="line">    功能：回收指定进程号的子进程，可以设置是否阻塞。</span><br><span class="line">    参数：</span><br><span class="line">        - pid:</span><br><span class="line">            pid &gt; 0 : 某个子进程的pid</span><br><span class="line">            pid &#x3D; 0 : 回收当前进程组的所有子进程    </span><br><span class="line">            pid &#x3D; -1 : 回收所有的子进程，相当于 wait()  （最常用）</span><br><span class="line">            pid &lt; -1 : 某个进程组的组id的绝对值，回收指定进程组中的子进程</span><br><span class="line">        - options：设置阻塞或者非阻塞</span><br><span class="line">            0 : 阻塞</span><br><span class="line">            WNOHANG : 非阻塞</span><br><span class="line">        - 返回值：</span><br><span class="line">            &gt; 0 : 返回子进程的id</span><br><span class="line">            &#x3D; 0 : options&#x3D;WNOHANG, 表示还有子进程或者</span><br><span class="line">            &#x3D; -1 ：错误，或者没有子进程了</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h1><h2 id="进程间通讯概念"><a href="#进程间通讯概念" class="headerlink" title="进程间通讯概念"></a>进程间通讯概念</h2><ul>
<li>进程是一个独立的资源分配单元，不同进程（这里所说的进程通常指的是用户进程）之间 的资源是独立的，没有关联，不能在一个进程中直接访问另一个进程的资源。</li>
<li>但是，进程不是孤立的，不同的进程需要进行信息的交互和状态的传递等，因此需要进程 间通信( IPC：Inter Processes Communication )。</li>
<li>进程间通信的目的：<ul>
<li>数据传输：一个进程需要将它的数据发送给另一个进程。</li>
<li>通知事件：一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如进程终止时要通知父进程）。</li>
<li>资源共享：多个进程之间共享同样的资源。为了做到这一点，需要内核提供互斥和同步机制。</li>
<li>进程控制：有些进程希望完全控制另一个进程的执行（如 Debug 进程），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。</li>
</ul>
</li>
</ul>
<h2 id="Linux进程间通信的方式"><a href="#Linux进程间通信的方式" class="headerlink" title="Linux进程间通信的方式"></a>Linux进程间通信的方式</h2><p>同一主机进程间通信：</p>
<ul>
<li>Unix进程间通信方式：<ul>
<li>匿名管道</li>
<li>有名管道</li>
<li>信号</li>
</ul>
</li>
<li>System V进程间通信方式 &amp; POSIX进程间通信方式：<ul>
<li>消息队列</li>
<li>共享内存</li>
<li>信号量</li>
</ul>
</li>
</ul>
<p>不同主机（网络）进程间通信：</p>
<ul>
<li>Socket</li>
</ul>
<h2 id="匿名管道"><a href="#匿名管道" class="headerlink" title="匿名管道"></a>匿名管道</h2><ul>
<li><p>管道也叫无名（匿名）管道，它是是 UNIX 系统 IPC（进程间通信）的最古老形式，所有的 UNIX 系统都支持这种通信机制。</p>
</li>
<li><p>统计一个目录中文件的数目命令：ls | wc –l，为了执行该命令，shell 创建了两个进程来分别执行 ls 和 wc。（ ｜ 管道符）</p>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9dc011a5-5e65-46d6-9b0b-d1731809f1b3/Untitled.png" alt="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9dc011a5-5e65-46d6-9b0b-d1731809f1b3/Untitled.png"></p>
</li>
</ul>
<h3 id="管道的特点"><a href="#管道的特点" class="headerlink" title="管道的特点"></a>管道的特点</h3><ul>
<li>管道其实是一个在内核内存中维护的缓冲器，这个缓冲器的存储能力是有限的，不同的操作系统大小不一定相同。</li>
<li>管道拥有文件的特质：读操作、写操作，匿名管道没有文件实体，有名管道有文件实体，但不存储数据。可以按照操作文件的方式对管道进行操作。</li>
<li>一个管道是一个字节流，使用管道时不存在消息或者消息边界的概念，从管道读取数据的进程可以读取任意大小的数据块，而不管写入进程写入管道的数据块的大小是多少。</li>
<li>通过管道传递的数据是顺序的，从管道中读取出来的字节的顺序和它们被写入管道的顺序是完全一样的。</li>
<li>在管道中的数据的传递方向是单向的，一端用于写入，一端用于读取，管道是半双工的。</li>
<li>从管道读数据是一次性操作，数据一旦被读走，它就从管道中被抛弃，释放空间以便写更多的数据，在管道中无法使用 lseek() 来随机的访问数据。</li>
<li>匿名管道只能在具有公共祖先的进程（父进程与子进程，或者两个兄弟进程，具有亲缘关系）之间使用。</li>
</ul>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f58c1173-afe4-4057-9771-f116833388ca/Untitled.png" alt="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f58c1173-afe4-4057-9771-f116833388ca/Untitled.png"></p>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0e119e93-68b0-43bb-9248-7bb7f097c537/Untitled.png" alt="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0e119e93-68b0-43bb-9248-7bb7f097c537/Untitled.png"></p>
<h3 id="匿名管道的使用"><a href="#匿名管道的使用" class="headerlink" title="匿名管道的使用"></a>匿名管道的使用</h3><ul>
<li><p>创建匿名管道</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int pipe(int pipefd[2]);</span><br><span class="line">    功能：创建一个匿名管道，用来进程间通信。</span><br><span class="line">    参数：int pipefd[2] 这个数组是一个传出参数。</span><br><span class="line">        pipefd[0] 对应的是管道的读端</span><br><span class="line">        pipefd[1] 对应的是管道的写端</span><br><span class="line">    返回值：</span><br><span class="line">        成功 0</span><br><span class="line">        失败 -1</span><br><span class="line"></span><br><span class="line">管道默认是阻塞的：如果管道中没有数据，read阻塞，如果管道满了，write阻塞</span><br><span class="line"></span><br><span class="line">注意：匿名管道只能用于具有关系的进程之间的通信（父子进程，兄弟进程）</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看管道缓冲大小命令</p>
<p>ulimit -a</p>
</li>
<li><p>查看管道缓冲大小函数</p>
<p>#include &lt;unistd.h&gt;</p>
<p>long fpathconf(int fd, int name);</p>
</li>
</ul>
<h2 id="有名管道"><a href="#有名管道" class="headerlink" title="有名管道"></a>有名管道</h2><ul>
<li>匿名管道，由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道（FIFO），也叫命名管道、FIFO文件。</li>
<li>有名管道（FIFO）不同于匿名管道之处在于它提供了一个路径名与之关联，以 FIFO的文件形式存在于文件系统中，并且其打开方式与打开一个普通文件是一样的，这样即使与 FIFO 的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过 FIFO 相互通信，因此，通过 FIFO 不相关的进程也能交换数据。</li>
<li>一旦打开了 FIFO，就能在它上面使用与操作匿名管道和其他文件的系统调用一样的I/O系统调用了（如read()、write()和close()）。与管道一样，FIFO 也有一个写入端和读取端，并且从管道中读取数据的顺序与写入的顺序是一样的。FIFO 的名称也由此而来：先入先出。</li>
<li>有名管道（FIFO)和匿名管道（pipe）有一些特点是相同的，不一样的地方在于：<ol>
<li>FIFO 在文件系统中作为一个特殊文件存在，但 FIFO 中的内容却存放在内存中。</li>
<li>当使用 FIFO 的进程退出后，FIFO 文件将继续保存在文件系统中以便以后使用。</li>
<li>FIFO 有名字，不相关的进程可以通过打开有名管道进行通信。</li>
</ol>
</li>
</ul>
<h3 id="有名管道的使用"><a href="#有名管道的使用" class="headerlink" title="有名管道的使用"></a>有名管道的使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">创建fifo文件</span><br><span class="line">1.通过命令： mkfifo 名字</span><br><span class="line">2.通过函数：int mkfifo(const char *pathname, mode_t mode);</span><br><span class="line"></span><br><span class="line">#include &lt;sys&#x2F;types.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;stat.h&gt;</span><br><span class="line">int mkfifo(const char *pathname, mode_t mode);</span><br><span class="line">    参数：</span><br><span class="line">        - pathname: 管道名称的路径</span><br><span class="line">        - mode: 文件的权限 和 open 的 mode 是一样的</span><br><span class="line">                是一个八进制的数</span><br><span class="line">    返回值：成功返回0，失败返回-1，并设置错误号</span><br><span class="line"></span><br><span class="line">有名管道的注意事项：</span><br><span class="line">    1.一个为只读而打开一个管道的进程会阻塞，直到另外一个进程为只写打开管道</span><br><span class="line">    2.一个为只写而打开一个管道的进程会阻塞，直到另外一个进程为只读打开管道</span><br><span class="line"></span><br><span class="line">读管道：</span><br><span class="line">    管道中有数据，read返回实际读到的字节数</span><br><span class="line">    管道中无数据：</span><br><span class="line">        管道写端被全部关闭，read返回0，（相当于读到文件末尾）</span><br><span class="line">        写端没有全部被关闭，read阻塞等待</span><br><span class="line"></span><br><span class="line">写管道：</span><br><span class="line">    管道读端被全部关闭，进行异常终止（收到一个SIGPIPE信号）</span><br><span class="line">    管道读端没有全部关闭：</span><br><span class="line">        管道已经满了，write会阻塞</span><br><span class="line">        管道没有满，write将数据写入，并返回实际写入的字节数。</span><br></pre></td></tr></table></figure>

<ul>
<li>一旦使用 mkfifo 创建了一个 FIFO，就可以使用 open 打开它，常见的文件I/O 函数都可用于 fifo。如：close、read、write、unlink 等。</li>
<li>FIFO 严格遵循先进先出（First in First out），对管道及 FIFO 的读总是从开始处返回数据，对它们的写则把数据添加到末尾。它们不支持诸如 lseek()等文件定位操作。</li>
</ul>
<h2 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h2><p>内存映射（Memory-mapped I/O）是将磁盘文件的数据映射到内存，用户通过修改内存就能修改磁盘文件。</p>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f930a6c0-dfc7-4478-b7bf-85d0053f627b/Untitled.png" alt="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f930a6c0-dfc7-4478-b7bf-85d0053f627b/Untitled.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys&#x2F;mman.h&gt;</span><br><span class="line">void *mmap(void *addr, size_t length, int prot, int flags,int fd, off_t offset);</span><br><span class="line">    - 功能：将一个文件或者设备的数据映射到内存中</span><br><span class="line">    - 参数：</span><br><span class="line">        - void *addr: NULL, 由内核指定</span><br><span class="line">        - length : 要映射的数据的长度，这个值不能为0。建议使用文件的长度。</span><br><span class="line">                获取文件的长度：stat lseek</span><br><span class="line">        - prot : 对申请的内存映射区的操作权限</span><br><span class="line">            -PROT_EXEC ：可执行的权限</span><br><span class="line">            -PROT_READ ：读权限</span><br><span class="line">            -PROT_WRITE ：写权限</span><br><span class="line">            -PROT_NONE ：没有权限</span><br><span class="line">            要操作映射内存，必须要有读的权限。</span><br><span class="line">            PROT_READ、PROT_READ|PROT_WRITE</span><br><span class="line">        - flags :</span><br><span class="line">            - MAP_SHARED : 映射区的数据会自动和磁盘文件进行同步，进程间通信，必须要设置这个选项</span><br><span class="line">            - MAP_PRIVATE ：不同步，内存映射区的数据改变了，对原来的文件不会修改，会重新创建一个新的文件。（copy on write）</span><br><span class="line">        - fd: 需要映射的那个文件的文件描述符</span><br><span class="line">            - 通过open得到，open的是一个磁盘文件</span><br><span class="line">            - 注意：文件的大小不能为0，open指定的权限不能和prot参数有冲突。</span><br><span class="line">                prot: PROT_READ                open:只读&#x2F;读写 </span><br><span class="line">                prot: PROT_READ | PROT_WRITE   open:读写</span><br><span class="line">        - offset：偏移量，一般不用。必须指定的是4k的整数倍，0表示不便宜。</span><br><span class="line">    - 返回值：返回创建的内存的首地址</span><br><span class="line">        失败返回MAP_FAILED，(void *) -1</span><br><span class="line"></span><br><span class="line">int munmap(void *addr, size_t length);</span><br><span class="line">    - 功能：释放内存映射</span><br><span class="line">    - 参数：</span><br><span class="line">        - addr : 要释放的内存的首地址</span><br><span class="line">        - length : 要释放的内存的大小，要和mmap函数中的length参数的值一样。</span><br><span class="line">使用内存映射实现进程间通信：</span><br><span class="line">1.有关系的进程（父子进程）</span><br><span class="line">    - 还没有子进程的时候</span><br><span class="line">        - 通过唯一的父进程，先创建内存映射区</span><br><span class="line">    - 有了内存映射区以后，创建子进程</span><br><span class="line">    - 父子进程共享创建的内存映射区</span><br><span class="line"></span><br><span class="line">2.没有关系的进程间通信</span><br><span class="line">    - 准备一个大小不是0的磁盘文件</span><br><span class="line">    - 进程1 通过磁盘文件创建内存映射区</span><br><span class="line">        - 得到一个操作这块内存的指针</span><br><span class="line">    - 进程2 通过磁盘文件创建内存映射区</span><br><span class="line">        - 得到一个操作这块内存的指针</span><br><span class="line">    - 使用内存映射区通信</span><br><span class="line"></span><br><span class="line">注意：内存映射区通信，是非阻塞。</span><br><span class="line">1.如果对mmap的返回值(ptr)做++操作(ptr++), munmap是否能够成功?</span><br><span class="line">	void * ptr &#x3D; mmap(...);</span><br><span class="line">	ptr++;  可以对其进行++操作</span><br><span class="line">	munmap(ptr, len);   &#x2F;&#x2F; 错误,要保存地址</span><br><span class="line">	</span><br><span class="line">2.如果open时O_RDONLY, mmap时prot参数指定PROT_READ | PROT_WRITE会怎样?</span><br><span class="line">	错误，返回MAP_FAILED</span><br><span class="line">	open()函数中的权限建议和prot参数的权限保持一致。</span><br><span class="line">	</span><br><span class="line">3.如果文件偏移量为1000会怎样?</span><br><span class="line">	偏移量必须是4K的整数倍，返回MAP_FAILED</span><br><span class="line"></span><br><span class="line">4.mmap什么情况下会调用失败?</span><br><span class="line">    - 第二个参数：length &#x3D; 0</span><br><span class="line">    - 第三个参数：prot</span><br><span class="line">        - 只指定了写权限</span><br><span class="line">        - prot PROT_READ | PROT_WRITE</span><br><span class="line">          第5个参数fd 通过open函数时指定的 O_RDONLY &#x2F; O_WRONLY</span><br><span class="line"></span><br><span class="line">5.可以open的时候O_CREAT一个新文件来创建映射区吗?</span><br><span class="line">    - 可以的，但是创建的文件的大小如果为0的话，肯定不行</span><br><span class="line">    - 可以对新的文件进行扩展</span><br><span class="line">        - lseek()</span><br><span class="line">        - truncate()</span><br><span class="line"></span><br><span class="line">6.mmap后关闭文件描述符，对mmap映射有没有影响？</span><br><span class="line">    int fd &#x3D; open(&quot;XXX&quot;);</span><br><span class="line">    mmap(,,,,fd,0);</span><br><span class="line">    close(fd); </span><br><span class="line">    映射区还存在，创建映射区的fd被关闭，没有任何影响。</span><br><span class="line"></span><br><span class="line">7.对ptr越界操作会怎样？</span><br><span class="line">	void * ptr &#x3D; mmap(NULL, 100,,,,,);</span><br><span class="line">	4K</span><br><span class="line">	越界操作操作的是非法的内存 -&gt; 段错误</span><br></pre></td></tr></table></figure>

<h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><ul>
<li>信号是 Linux 进程间通信的最古老的方式之一，是事件发生时对进程的通知机制，有时也称之为软中断，它是在软件层次上对中断机制的一种模拟，是一种异步通信的方式。信号可以导致一个正在运行的进程被另一个正在运行的异步进程中断，转而处理某一个突发事件。</li>
<li>发往进程的诸多信号，通常都是源于内核。引发内核为进程产生信号的各类事件如下：<ul>
<li>对于前台进程，用户可以通过输入特殊的终端字符来给它发送信号。比如输入Ctrl+C通常会给进程发送一个中断信号。</li>
<li>硬件发生异常，即硬件检测到一个错误条件并通知内核，随即再由内核发送相应信号给相关进程。比如执行一条异常的机器语言指令，诸如被 0 除，或者引用了无法访问的内存区域。</li>
<li>系统状态变化，比如 alarm 定时器到期将引起 SIGALRM 信号，进程执行的 CPU时间超限，或者该进程的某个子进程退出。</li>
<li>运行 kill 命令或调用 kill 函数。</li>
</ul>
</li>
<li>使用信号的两个主要目的是：<ul>
<li>让进程知道已经发生了一个特定的事情</li>
<li>强迫进程执行它自己代码中的信号处理程序</li>
</ul>
</li>
<li>信号的特点：<ul>
<li>简单</li>
<li>不能携带大量信息</li>
<li>满足某个特定条件才发送</li>
<li>优先级比较高</li>
</ul>
</li>
<li>查看系统定义的信号列表：kill -l</li>
<li>前31个信号为常规信号，其余为实时信号</li>
</ul>
<h3 id="部分信号一览"><a href="#部分信号一览" class="headerlink" title="部分信号一览"></a>部分信号一览</h3><ul>
<li>SIGINT：当用户按下了&lt;Ctrl+C&gt;组合键时，用户终端向正在运行中的由该终端启动的程序发出此信号（终止进程）</li>
<li>SIGQUIT：用户按下&lt;Ctrl+&gt;组合键时产生该信号，用户终端向正在运行中的由该终端启动的程序发出些信号（终止进程）</li>
<li>SIGKILL：无条件终止进程。该信号不能被忽略，处理和阻塞（终止进程，可以杀死任何进程）</li>
<li>SIGSEGV：指示进程进行了无效内存访问(段错误) （终止进程并产生core文件）</li>
<li>SIGPIPE：Broken pipe向一个没有读端的管道写数据 （终止进程）</li>
<li>SIGCHLD：子进程结束时，父进程会收到这个信号 （忽略这个信号）</li>
<li>SIGCONT：如果进程已停止，则使其继续运行（继续/忽略）</li>
<li>SIGSTOP：停止进程的执行。信号不能被忽略，处理和阻塞（为终止进程）</li>
</ul>
<h3 id="信号的5种默认处理动作"><a href="#信号的5种默认处理动作" class="headerlink" title="信号的5种默认处理动作"></a>信号的5种默认处理动作</h3><ul>
<li>查看信号的详细信息：man 7 signal</li>
<li>信号的5种默认处理动作<ul>
<li>Term 终止进程</li>
<li>Ign 当前进程忽略掉这个信号</li>
<li>Core 终止进程，并生成一个Core文件</li>
<li>Stop 暂停当前进程</li>
<li>Cont 继续执行当前被暂停的进程</li>
</ul>
</li>
<li>信号的几种状态： 产生、未决、递达</li>
<li>SIGKILL 和 SIGSTOP 信号不能被捕捉、阻塞或者忽略，只能执行默认动作。</li>
</ul>
<h3 id="信号相关的函数"><a href="#信号相关的函数" class="headerlink" title="信号相关的函数"></a>信号相关的函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys&#x2F;types.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line"></span><br><span class="line">int kill(pid_t pid, int sig);</span><br><span class="line">    - 功能：给任何的进程或者进程组pid, 发送任何的信号 sig</span><br><span class="line">    - 参数：</span><br><span class="line">        - pid ：</span><br><span class="line">            &gt; 0 : 将信号发送给指定的进程</span><br><span class="line">            &#x3D; 0 : 将信号发送给当前的进程组</span><br><span class="line">            &#x3D; -1 : 将信号发送给每一个有权限接收这个信号的进程</span><br><span class="line">            &lt; -1 : 这个pid&#x3D;某个进程组的ID取反 （-12345）</span><br><span class="line">        - sig : 需要发送的信号的编号或者是宏值，0表示不发送任何信号</span><br><span class="line"></span><br><span class="line">    kill(getppid(), 9);</span><br><span class="line">    kill(getpid(), 9);</span><br><span class="line">    </span><br><span class="line">int raise(int sig);</span><br><span class="line">    - 功能：给当前进程发送信号</span><br><span class="line">    - 参数：</span><br><span class="line">        - sig : 要发送的信号</span><br><span class="line">    - 返回值：</span><br><span class="line">        - 成功 0</span><br><span class="line">        - 失败 非0</span><br><span class="line">    kill(getpid(), sig);   </span><br><span class="line"></span><br><span class="line">void abort(void);</span><br><span class="line">    - 功能： 发送SIGABRT信号给当前的进程，杀死当前进程</span><br><span class="line">    kill(getpid(), SIGABRT);</span><br><span class="line"></span><br><span class="line">unsigned int alarm(unsigned int seconds);</span><br><span class="line">    - 功能：设置定时器（闹钟）。函数调用，开始倒计时，当倒计时为0的时候，</span><br><span class="line">            函数会给当前的进程发送一个信号：SIGALARM</span><br><span class="line">    - 参数：</span><br><span class="line">        seconds: 倒计时的时长，单位：秒。如果参数为0，定时器无效（不进行倒计时，不发信号）。</span><br><span class="line">                取消一个定时器，通过alarm(0)。</span><br><span class="line">    - 返回值：</span><br><span class="line">        - 之前没有定时器，返回0</span><br><span class="line">        - 之前有定时器，返回之前的定时器剩余的时间</span><br><span class="line"></span><br><span class="line">- SIGALARM ：默认终止当前的进程，每一个进程都有且只有唯一的一个定时器。</span><br><span class="line">    alarm(10);  -&gt; 返回0</span><br><span class="line">    过了1秒</span><br><span class="line">    alarm(5);   -&gt; 返回9</span><br><span class="line"></span><br><span class="line">alarm(100) -&gt; 该函数是不阻塞的</span><br><span class="line"></span><br><span class="line">int setitimer(int which, const struct itimerval *new_value,</span><br><span class="line">								struct itimerval *old_value);</span><br><span class="line"></span><br><span class="line">    - 功能：设置定时器（闹钟）。可以替代alarm函数。精度微妙us，可以实现周期性定时</span><br><span class="line">    - 参数：</span><br><span class="line">        - which : 定时器以什么时间计时</span><br><span class="line">          ITIMER_REAL: 真实时间，时间到达，发送 SIGALRM   常用</span><br><span class="line">          ITIMER_VIRTUAL: 用户时间，时间到达，发送 SIGVTALRM</span><br><span class="line">          ITIMER_PROF: 以该进程在用户态和内核态下所消耗的时间来计算，时间到达，发送 SIGPROF</span><br><span class="line"></span><br><span class="line">        - new_value: 设置定时器的属性</span><br><span class="line">        </span><br><span class="line">            struct itimerval &#123;      &#x2F;&#x2F; 定时器的结构体</span><br><span class="line">            struct timeval it_interval;  &#x2F;&#x2F; 每个阶段的时间，间隔时间</span><br><span class="line">            struct timeval it_value;     &#x2F;&#x2F; 延迟多长时间执行定时器</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            struct timeval &#123;        &#x2F;&#x2F; 时间的结构体</span><br><span class="line">                time_t      tv_sec;     &#x2F;&#x2F;  秒数     </span><br><span class="line">                suseconds_t tv_usec;    &#x2F;&#x2F;  微秒    </span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">        过10秒后，每个2秒定时一次</span><br><span class="line">       </span><br><span class="line">        - old_value ：记录上一次的定时的时间参数，一般不使用，指定NULL</span><br><span class="line">    </span><br><span class="line">    - 返回值：</span><br><span class="line">        成功 0</span><br><span class="line">        失败 -1 并设置错误号</span><br></pre></td></tr></table></figure>

<h3 id="signal信号捕捉"><a href="#signal信号捕捉" class="headerlink" title="signal信号捕捉"></a>signal信号捕捉</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">typedef void (*sighandler_t)(int);</span><br><span class="line">sighandler_t signal(int signum, sighandler_t handler);</span><br><span class="line">    - 功能：设置某个信号的捕捉行为</span><br><span class="line">    - 参数：</span><br><span class="line">        - signum: 要捕捉的信号</span><br><span class="line">        - handler: 捕捉到信号要如何处理</span><br><span class="line">            - SIG_IGN ： 忽略信号</span><br><span class="line">            - SIG_DFL ： 使用信号默认的行为</span><br><span class="line">            - 回调函数 :  这个函数是内核调用，程序员只负责写，捕捉到信号后如何去处理信号。</span><br><span class="line">            回调函数：</span><br><span class="line">                - 需要程序员实现，提前准备好的，函数的类型根据实际需求，看函数指针的定义</span><br><span class="line">                - 不是程序员调用，而是当信号产生，由内核调用</span><br><span class="line">                - 函数指针是实现回调的手段，函数实现之后，将函数名放到函数指针的位置就可以了。</span><br><span class="line"></span><br><span class="line">    - 返回值：</span><br><span class="line">        成功，返回上一次注册的信号处理函数的地址。第一次调用返回NULL</span><br><span class="line">        失败，返回SIG_ERR，设置错误号</span><br><span class="line">        </span><br><span class="line">SIGKILL SIGSTOP不能被捕捉，不能被忽略。</span><br></pre></td></tr></table></figure>

<h2 id="信号集及相关函数"><a href="#信号集及相关函数" class="headerlink" title="信号集及相关函数"></a>信号集及相关函数</h2><h3 id="信号集"><a href="#信号集" class="headerlink" title="信号集"></a>信号集</h3><ul>
<li>许多信号相关的系统调用都需要能表示一组不同的信号，多个信号可使用一个称之为信号集的数据结构来表示，其系统数据类型为 sigset_t。</li>
<li>在 PCB 中有两个非常重要的信号集。一个称之为 “阻塞信号集” ，另一个称之为“未决信号集” 。这两个信号集都是内核使用位图机制来实现的。但操作系统不允许我们直接对这两个信号集进行位操作。而需自定义另外一个集合，借助信号集操作函数来对 PCB 中的这两个信号集进行修改。</li>
<li>信号的 “未决” 是一种状态，指的是从信号的产生到信号被处理前的这一段时间。</li>
<li>信号的 “阻塞” 是一个开关动作，指的是阻止信号被处理，但不是阻止信号产生。</li>
<li>信号的阻塞就是让系统暂时保留信号留待以后发送。由于另外有办法让系统忽略信号，所以一般情况下信号的阻塞只是暂时的，只是为了防止信号打断敏感的操作。</li>
</ul>
<h3 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">以下信号集相关的函数都是对自定义的信号集进行操作。</span><br><span class="line"></span><br><span class="line">int sigemptyset(sigset_t *set);</span><br><span class="line">    - 功能：清空信号集中的数据,将信号集中的所有的标志位置为0</span><br><span class="line">    - 参数：set,传出参数，需要操作的信号集</span><br><span class="line">    - 返回值：成功返回0， 失败返回-1</span><br><span class="line"></span><br><span class="line">int sigfillset(sigset_t *set);</span><br><span class="line">    - 功能：将信号集中的所有的标志位置为1</span><br><span class="line">    - 参数：set,传出参数，需要操作的信号集</span><br><span class="line">    - 返回值：成功返回0， 失败返回-1</span><br><span class="line"></span><br><span class="line">int sigaddset(sigset_t *set, int signum);</span><br><span class="line">    - 功能：设置信号集中的某一个信号对应的标志位为1，表示阻塞这个信号</span><br><span class="line">    - 参数：</span><br><span class="line">        - set：传出参数，需要操作的信号集</span><br><span class="line">        - signum：需要设置阻塞的那个信号</span><br><span class="line">    - 返回值：成功返回0， 失败返回-1</span><br><span class="line"></span><br><span class="line">int sigdelset(sigset_t *set, int signum);</span><br><span class="line">    - 功能：设置信号集中的某一个信号对应的标志位为0，表示不阻塞这个信号</span><br><span class="line">    - 参数：</span><br><span class="line">        - set：传出参数，需要操作的信号集</span><br><span class="line">        - signum：需要设置不阻塞的那个信号</span><br><span class="line">    - 返回值：成功返回0， 失败返回-1</span><br><span class="line"></span><br><span class="line">int sigismember(const sigset_t *set, int signum);</span><br><span class="line">    - 功能：判断某个信号是否阻塞</span><br><span class="line">    - 参数：</span><br><span class="line">        - set：需要操作的信号集</span><br><span class="line">        - signum：需要判断的那个信号</span><br><span class="line">    - 返回值：</span><br><span class="line">        1 ： signum被阻塞</span><br><span class="line">        0 ： signum不阻塞</span><br><span class="line">        -1 ： 失败</span><br></pre></td></tr></table></figure>

<h3 id="信号处理过程"><a href="#信号处理过程" class="headerlink" title="信号处理过程"></a>信号处理过程</h3><ol>
<li>用户通过键盘  Ctrl + C, 产生2号信号SIGINT (信号被创建)</li>
<li>信号产生但是没有被处理 （未决）</li>
</ol>
<ul>
<li>在内核中将所有的没有被处理的信号存储在一个集合中 （未决信号集）</li>
<li>SIGINT信号状态被存储在第二个标志位上</li>
<li>这个标志位的值为0， 说明信号不是未决状态</li>
<li>这个标志位的值为1， 说明信号处于未决状态</li>
</ul>
<ol>
<li>这个未决状态的信号，需要被处理，处理之前需要和另一个信号集（阻塞信号集），进行比较</li>
</ol>
<ul>
<li>阻塞信号集默认不阻塞任何的信号</li>
<li>如果想要阻塞某些信号需要用户调用系统的API</li>
</ul>
<ol>
<li>在处理的时候和阻塞信号集中的标志位进行查询，看是不是对该信号设置阻塞了</li>
</ol>
<ul>
<li>如果没有阻塞，这个信号就被处理</li>
<li>如果阻塞了，这个信号就继续处于未决状态，直到阻塞解除，这个信号就被处理</li>
</ul>
<h3 id="sigprocmask函数"><a href="#sigprocmask函数" class="headerlink" title="sigprocmask函数"></a>sigprocmask函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);</span><br><span class="line">    - 功能：将自定义信号集中的数据设置到内核中（设置阻塞，解除阻塞，替换）</span><br><span class="line">    - 参数：</span><br><span class="line">        - how : 如何对内核阻塞信号集进行处理</span><br><span class="line">            SIG_BLOCK: 将用户设置的阻塞信号集添加到内核中，内核中原来的数据不变</span><br><span class="line">                假设内核中默认的阻塞信号集是mask， mask | set</span><br><span class="line">            SIG_UNBLOCK: 根据用户设置的数据，对内核中的数据进行解除阻塞</span><br><span class="line">                mask &amp;&#x3D; ~set</span><br><span class="line">            SIG_SETMASK:覆盖内核中原来的值</span><br><span class="line">        </span><br><span class="line">        - set ：已经初始化好的用户自定义的信号集</span><br><span class="line">        - oldset : 保存设置之前的内核中的阻塞信号集的状态，可以是 NULL</span><br><span class="line">    - 返回值：</span><br><span class="line">        成功：0</span><br><span class="line">        失败：-1</span><br><span class="line">            设置错误号：EFAULT、EINVAL</span><br><span class="line"></span><br><span class="line">int sigpending(sigset_t *set);</span><br><span class="line">    - 功能：获取内核中的未决信号集</span><br></pre></td></tr></table></figure>

<h3 id="sigaction信号捕捉函数"><a href="#sigaction信号捕捉函数" class="headerlink" title="sigaction信号捕捉函数"></a>sigaction信号捕捉函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">int sigaction(int signum, const struct sigaction *act,</span><br><span class="line">                        struct sigaction *oldact);</span><br><span class="line"></span><br><span class="line">    - 功能：检查或者改变信号的处理。信号捕捉</span><br><span class="line">    - 参数：</span><br><span class="line">        - signum : 需要捕捉的信号的编号或者宏值（信号的名称）</span><br><span class="line">        - act ：捕捉到信号之后的处理动作</span><br><span class="line">        - oldact : 上一次对信号捕捉相关的设置，一般不使用，传递NULL</span><br><span class="line">    - 返回值：</span><br><span class="line">        成功 0</span><br><span class="line">        失败 -1</span><br><span class="line"></span><br><span class="line"> struct sigaction &#123;</span><br><span class="line">    &#x2F;&#x2F; 函数指针，指向的函数就是信号捕捉到之后的处理函数</span><br><span class="line">    void     (*sa_handler)(int);</span><br><span class="line">    &#x2F;&#x2F; 不常用</span><br><span class="line">    void     (*sa_sigaction)(int, siginfo_t *, void *);</span><br><span class="line">    &#x2F;&#x2F; 临时阻塞信号集，在信号捕捉函数执行过程中，临时阻塞某些信号。</span><br><span class="line">    sigset_t   sa_mask;</span><br><span class="line">    &#x2F;&#x2F; 使用哪一个信号处理对捕捉到的信号进行处理</span><br><span class="line">    &#x2F;&#x2F; 这个值可以是0，表示使用sa_handler,也可以是SA_SIGINFO表示使用sa_sigaction</span><br><span class="line">    int        sa_flags;</span><br><span class="line">    &#x2F;&#x2F; 被废弃掉了</span><br><span class="line">    void     (*sa_restorer)(void);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="SIGCHLD信号"><a href="#SIGCHLD信号" class="headerlink" title="SIGCHLD信号"></a>SIGCHLD信号</h3><p>产生的三个条件：</p>
<ol>
<li>子进程结束</li>
<li>子进程暂停</li>
<li>子进程继续运行</li>
</ol>
<p>都会给父进程发送该信号，父进程默认忽略该信号</p>
<ul>
<li>可以使用SIGCHLD信号解决僵尸进程的问题。</li>
</ul>
<h2 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h2><p>共享内存允许两个或者多个进程共享物理内存的同一块区域（通常被称为段）。由于一个共享内存段会称为一个进程用户空间的一部分，因此这种 IPC 机制无需内核介入。所有需要做的就是让一个进程将数据复制进共享内存中，并且这部分数据会对其他所有共享同一个段的进程可用。</p>
<p>与管道等要求发送进程将数据从用户空间的缓冲区复制进内核内存和接收进程将数据从内核内存复制进用户空间的缓冲区的做法相比，这种 IPC 技术的速度更快。</p>
<h3 id="共享内存使用步骤"><a href="#共享内存使用步骤" class="headerlink" title="共享内存使用步骤"></a>共享内存使用步骤</h3><ul>
<li>调用 shmget() 创建一个新共享内存段或取得一个既有共享内存段的标识符（即由其他进程创建的共享内存段）。这个调用将返回后续调用中需要用到的共享内存标识符。</li>
<li>使用 shmat() 来附上共享内存段，即使该段成为调用进程的虚拟内存的一部分。</li>
<li>此刻在程序中可以像对待其他可用内存那样对待这个共享内存段。为引用这块共享内存，程序需要使用由 shmat() 调用返回的 addr 值，它是一个指向进程的虚拟地址空间中该共享内存段的起点的指针。</li>
<li>调用 shmdt() 来分离共享内存段。在这个调用之后，进程就无法再引用这块共享内存了。这一步是可选的，并且在进程终止时会自动完成这一步。</li>
</ul>
<p>调用 shmctl() 来删除共享内存段。只有当当前所有附加内存段的进程都与之分离之后内存段才会销毁。只有一个进程需要执行这一步。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys&#x2F;ipc.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;shm.h&gt;</span><br><span class="line"></span><br><span class="line">int shmget(key_t key, size_t size, int shmflg);</span><br><span class="line">    - 功能：创建一个新的共享内存段，或者获取一个既有的共享内存段的标识。</span><br><span class="line">        新创建的内存段中的数据都会被初始化为0</span><br><span class="line">    - 参数：</span><br><span class="line">        - key : key_t类型是一个整形，通过这个找到或者创建一个共享内存。</span><br><span class="line">                一般使用16进制表示，非0值</span><br><span class="line">        - size: 共享内存的大小</span><br><span class="line">        - shmflg: 属性</span><br><span class="line">            - 访问权限</span><br><span class="line">            - 附加属性：创建&#x2F;判断共享内存是不是存在</span><br><span class="line">                - 创建：IPC_CREAT</span><br><span class="line">                - 判断共享内存是否存在： IPC_EXCL , 需要和IPC_CREAT一起使用</span><br><span class="line">                    IPC_CREAT | IPC_EXCL | 0664</span><br><span class="line">        - 返回值：</span><br><span class="line">            失败：-1 并设置错误号</span><br><span class="line">            成功：&gt;0 返回共享内存的引用的ID，后面操作共享内存都是通过这个值。</span><br><span class="line"></span><br><span class="line">void *shmat(int shmid, const void *shmaddr, int shmflg);</span><br><span class="line">    - 功能：和当前的进程进行关联</span><br><span class="line">    - 参数：</span><br><span class="line">        - shmid : 共享内存的标识（ID）,由shmget返回值获取</span><br><span class="line">        - shmaddr: 申请的共享内存的起始地址，指定NULL，内核指定</span><br><span class="line">        - shmflg : 对共享内存的操作</span><br><span class="line">            - 读 ： SHM_RDONLY, 必须要有读权限</span><br><span class="line">            - 读写： 0</span><br><span class="line">    - 返回值：</span><br><span class="line">        成功：返回共享内存的首（起始）地址。  失败(void *) -1</span><br><span class="line"></span><br><span class="line">int shmdt(const void *shmaddr);</span><br><span class="line">    - 功能：解除当前进程和共享内存的关联</span><br><span class="line">    - 参数：</span><br><span class="line">        shmaddr：共享内存的首地址</span><br><span class="line">    - 返回值：成功 0， 失败 -1</span><br><span class="line"></span><br><span class="line">int shmctl(int shmid, int cmd, struct shmid_ds *buf);</span><br><span class="line">    - 功能：对共享内存进行操作。删除共享内存，共享内存要删除才会消失，创建共享内存的进行被销毁了对共享内存是没有任何影响。</span><br><span class="line">    - 参数：</span><br><span class="line">        - shmid: 共享内存的ID</span><br><span class="line">        - cmd : 要做的操作</span><br><span class="line">            - IPC_STAT : 获取共享内存的当前的状态</span><br><span class="line">            - IPC_SET : 设置共享内存的状态</span><br><span class="line">            - IPC_RMID: 标记共享内存被销毁</span><br><span class="line">        - buf：需要设置或者获取的共享内存的属性信息</span><br><span class="line">            - IPC_STAT : buf存储数据</span><br><span class="line">            - IPC_SET : buf中需要初始化数据，设置到内核中</span><br><span class="line">            - IPC_RMID : 没有用，NULL</span><br><span class="line"></span><br><span class="line">key_t ftok(const char *pathname, int proj_id);</span><br><span class="line">    - 功能：根据指定的路径名，和int值，生成一个共享内存的key</span><br><span class="line">    - 参数：</span><br><span class="line">        - pathname:指定一个存在的路径</span><br><span class="line">            &#x2F;home&#x2F;nowcoder&#x2F;Linux&#x2F;a.txt</span><br><span class="line">            &#x2F; </span><br><span class="line">        - proj_id: int类型的值，但是这系统调用只会使用其中的1个字节</span><br><span class="line">                   范围 ： 0-255  一般指定一个字符 &#39;a&#39;</span><br><span class="line"></span><br><span class="line">问题1：操作系统如何知道一块共享内存被多少个进程关联？</span><br><span class="line">    - 共享内存维护了一个结构体struct shmid_ds 这个结构体中有一个成员 shm_nattch</span><br><span class="line">    - shm_nattach 记录了关联的进程个数</span><br><span class="line"></span><br><span class="line">问题2：可不可以对共享内存进行多次删除 shmctl</span><br><span class="line">    - 可以的</span><br><span class="line">    - 因为shmctl 标记删除共享内存，不是直接删除</span><br><span class="line">    - 什么时候真正删除呢?</span><br><span class="line">        当和共享内存关联的进程数为0的时候，就真正被删除</span><br><span class="line">    - 当共享内存的key为0的时候，表示共享内存被标记删除了</span><br><span class="line">        如果一个进程和共享内存取消关联，那么这个进程就不能继续操作这个共享内存。也不能进行关联。</span><br></pre></td></tr></table></figure>

<h3 id="共享内存和内存映射的区别"><a href="#共享内存和内存映射的区别" class="headerlink" title="共享内存和内存映射的区别"></a>共享内存和内存映射的区别</h3><ol>
<li>共享内存可以直接创建，内存映射需要磁盘文件（匿名映射除外）</li>
<li>共享内存效果更高</li>
<li>内存 所有的进程操作的是同一块共享内存。 内存映射，每个进程在自己的虚拟地址空间中有一个独立的内存。</li>
<li>数据安全<ul>
<li>进程突然退出 共享内存还存在 内存映射区消失</li>
<li>运行进程的电脑死机，宕机了 数据存在在共享内存中，没有了 内存映射区的数据 ，由于磁盘文件中的数据还在，所以内存映射区的数据还存在。</li>
</ul>
</li>
<li>生命周期<ul>
<li>内存映射区：进程退出，内存映射区销毁</li>
<li>共享内存：进程退出，共享内存还在，标记删除（所有的关联的进程数为0），或者关机 如果一个进程退出，会自动和共享内存进行取消关联。</li>
</ul>
</li>
</ol>
<h3 id="共享内存操作命令"><a href="#共享内存操作命令" class="headerlink" title="共享内存操作命令"></a>共享内存操作命令</h3><ul>
<li><p>ipcs 用法</p>
<p> ipcs -a // 打印当前系统中所有的进程间通信方式的信息</p>
<p> ipcs -m // 打印出使用共享内存进行进程间通信的信息</p>
<p> ipcs -q // 打印出使用消息队列进行进程间通信的信息</p>
<p> ipcs -s // 打印出使用信号进行进程间通信的信息</p>
</li>
<li><p>ipcrm 用法</p>
<p> ipcrm -M shmkey // 移除用shmkey创建的共享内存段</p>
<p> ipcrm -m shmid // 移除用shmid标识的共享内存段</p>
<p> ipcrm -Q msgkey // 移除用msqkey创建的消息队列</p>
<p> ipcrm -q msqid // 移除用msqid标识的消息队列</p>
<p> ipcrm -S semkey // 移除用semkey创建的信号</p>
<p> ipcrm -s semid // 移除用semid标识的信号</p>
</li>
</ul>
<h2 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h2><h3 id="终端"><a href="#终端" class="headerlink" title="终端"></a>终端</h3><ul>
<li>在 UNIX 系统中，用户通过终端登录系统后得到一个 shell 进程，这个终端成为 shell 进程的控制终端（Controlling Terminal），进程中，控制终端是保存在 PCB 中的信息，而 fork() 会复制 PCB 中的信息，因此由 shell 进程启动的其它进程的控制终端也是这个终端。</li>
<li>默认情况下（没有重定向），每个进程的标准输入、标准输出和标准错误输出都指向控制终端，进程从标准输入读也就是读用户的键盘输入，进程往标准输出或标准错误输出写也就是输出到显示器上。</li>
<li>在控制终端输入一些特殊的控制键可以给前台进程发信号，例如 Ctrl + C 会产生 SIGINT 信号，Ctrl + \ 会产生 SIGQUIT 信号。</li>
</ul>
<h3 id="进程组"><a href="#进程组" class="headerlink" title="进程组"></a>进程组</h3><ul>
<li>进程组和会话在进程之间形成了一种两级层次关系：进程组是一组相关进程的集合，会话是一组相关进程组的集合。进程组和会话是为支持 shell 作业控制而定义的抽象概念，用户通过 shell 能够交互式地在前台或后台运行命令。</li>
<li>进行组由一个或多个共享同一进程组标识符（PGID）的进程组成。一个进程组拥有一个进程组首进程，该进程是创建该组的进程，其进程 ID 为该进程组的 ID，新进程会继承其父进程所属的进程组 ID。</li>
<li>进程组拥有一个生命周期，其开始时间为首进程创建组的时刻，结束时间为最后一个成员进程退出组的时刻。一个进程可能会因为终止而退出进程组，也可能会因为加入了另外一个进程组而退出进程组。进程组首进程无需是最后一个离开进程组的成员。</li>
</ul>
<h3 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h3><ul>
<li>会话是一组进程组的集合。会话首进程是创建该新会话的进程，其进程 ID 会成为会话 ID。新进程会继承其父进程的会话 ID。</li>
<li>一个会话中的所有进程共享单个控制终端。控制终端会在会话首进程首次打开一个终端设备时被建立。一个终端最多可能会成为一个会话的控制终端。</li>
<li>在任一时刻，会话中的其中一个进程组会成为终端的前台进程组，其他进程组会成为后台进程组。只有前台进程组中的进程才能从控制终端中读取输入。当用户在控制终端中输入终端字符生成信号后，该信号会被发送到前台进程组中的所有成员。</li>
<li>当控制终端的连接建立起来之后，会话首进程会成为该终端的控制进程。</li>
</ul>
<h3 id="进程组、会话、控制终端之间的关系"><a href="#进程组、会话、控制终端之间的关系" class="headerlink" title="进程组、会话、控制终端之间的关系"></a>进程组、会话、控制终端之间的关系</h3><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/09a88cdd-814c-4091-8c37-0fbbb1d361e5/Untitled.png" alt="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/09a88cdd-814c-4091-8c37-0fbbb1d361e5/Untitled.png"></p>
<h3 id="进程组、会话操作函数"><a href="#进程组、会话操作函数" class="headerlink" title="进程组、会话操作函数"></a>进程组、会话操作函数</h3><ul>
<li>pid_t getpgrp(void);</li>
<li>pid_t getpgid(pid_t pid);</li>
<li>int setpgid(pid_t pid, pid_t pgid);</li>
<li>pid_t getsid(pid_t pid);</li>
<li>pid_t setsid(void);</li>
</ul>
<h3 id="守护进程-1"><a href="#守护进程-1" class="headerlink" title="守护进程"></a>守护进程</h3><ul>
<li>守护进程（Daemon Process），也就是通常说的 Daemon 进程（精灵进程），是Linux 中的后台服务进程。它是一个生存期较长的进程，通常独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。一般采用以 d 结尾的名字。</li>
<li>守护进程具备下列特征：<ul>
<li>生命周期很长，守护进程会在系统启动的时候被创建并一直运行直至系统被关闭。</li>
<li>它在后台运行并且不拥有控制终端。没有控制终端确保了内核永远不会为守护进程自动生成任何控制信号以及终端相关的信号（如 SIGINT、SIGQUIT）。</li>
</ul>
</li>
<li>Linux 的大多数服务器就是用守护进程实现的。比如，Internet 服务器 inetd，Web 服务器 httpd 等。</li>
</ul>
<h3 id="守护进程的创建步骤"><a href="#守护进程的创建步骤" class="headerlink" title="守护进程的创建步骤"></a>守护进程的创建步骤</h3><ul>
<li>执行一个 fork()，之后父进程退出，子进程继续执行。</li>
<li>子进程调用 setsid() 开启一个新会话。</li>
<li>清除进程的 umask 以确保当守护进程创建文件和目录时拥有所需的权限。</li>
<li>修改进程的当前工作目录，通常会改为根目录（/）。</li>
<li>关闭守护进程从其父进程继承而来的所有打开着的文件描述符。</li>
<li>在关闭了文件描述符0、1、2之后，守护进程通常会打开/dev/null 并使用dup2()使所有这些描述符指向这个设备。</li>
<li>核心业务逻辑</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Linux%EF%BC%8C%E5%A4%9A%E8%BF%9B%E7%A8%8B/" rel="tag"># Linux，多进程</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/03/31/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/" rel="prev" title="Linux系统编程笔记">
      <i class="fa fa-chevron-left"></i> Linux系统编程笔记
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E6%A6%82%E8%BF%B0"><span class="nav-number">1.</span> <span class="nav-text">进程概述</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E7%89%87"><span class="nav-number">1.1.</span> <span class="nav-text">时间片</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97%EF%BC%88PCB%EF%BC%89"><span class="nav-number">1.2.</span> <span class="nav-text">进程控制块（PCB）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2"><span class="nav-number">2.</span> <span class="nav-text">进程状态转换</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4"><span class="nav-number">2.1.</span> <span class="nav-text">进程相关命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%8F%B7%E5%92%8C%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="nav-number">2.2.</span> <span class="nav-text">进程号和相关函数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA"><span class="nav-number">3.</span> <span class="nav-text">进程创建</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#exec%E5%87%BD%E6%95%B0%E6%97%8F"><span class="nav-number">4.</span> <span class="nav-text">exec函数族</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#exec%E5%87%BD%E6%95%B0%E6%97%8F-1"><span class="nav-number">4.1.</span> <span class="nav-text">exec函数族</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#execl"><span class="nav-number">4.1.1.</span> <span class="nav-text">execl</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#execlp"><span class="nav-number">4.1.2.</span> <span class="nav-text">execlp</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E9%80%80%E5%87%BA%E3%80%81%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B%E3%80%81%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B"><span class="nav-number">5.</span> <span class="nav-text">进程退出、孤儿进程、僵尸进程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E9%80%80%E5%87%BA"><span class="nav-number">5.1.</span> <span class="nav-text">进程退出</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B"><span class="nav-number">5.2.</span> <span class="nav-text">孤儿进程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B"><span class="nav-number">5.3.</span> <span class="nav-text">僵尸进程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%9B%9E%E6%94%B6"><span class="nav-number">5.4.</span> <span class="nav-text">进程回收</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%80%E5%87%BA%E4%BF%A1%E6%81%AF%E7%9B%B8%E5%85%B3%E5%AE%8F%E5%87%BD%E6%95%B0"><span class="nav-number">5.5.</span> <span class="nav-text">退出信息相关宏函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#wait%E5%92%8Cwaitpid%E5%87%BD%E6%95%B0"><span class="nav-number">5.6.</span> <span class="nav-text">wait和waitpid函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#wait%E5%87%BD%E6%95%B0"><span class="nav-number">5.6.1.</span> <span class="nav-text">wait函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#waitpid%E5%87%BD%E6%95%B0"><span class="nav-number">5.6.2.</span> <span class="nav-text">waitpid函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="nav-number">6.</span> <span class="nav-text">进程间通信</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E8%AE%AF%E6%A6%82%E5%BF%B5"><span class="nav-number">6.1.</span> <span class="nav-text">进程间通讯概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-number">6.2.</span> <span class="nav-text">Linux进程间通信的方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8C%BF%E5%90%8D%E7%AE%A1%E9%81%93"><span class="nav-number">6.3.</span> <span class="nav-text">匿名管道</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%A1%E9%81%93%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-number">6.3.1.</span> <span class="nav-text">管道的特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%BF%E5%90%8D%E7%AE%A1%E9%81%93%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">6.3.2.</span> <span class="nav-text">匿名管道的使用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%89%E5%90%8D%E7%AE%A1%E9%81%93"><span class="nav-number">6.4.</span> <span class="nav-text">有名管道</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%89%E5%90%8D%E7%AE%A1%E9%81%93%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">6.4.1.</span> <span class="nav-text">有名管道的使用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84"><span class="nav-number">6.5.</span> <span class="nav-text">内存映射</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7"><span class="nav-number">6.6.</span> <span class="nav-text">信号</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%83%A8%E5%88%86%E4%BF%A1%E5%8F%B7%E4%B8%80%E8%A7%88"><span class="nav-number">6.6.1.</span> <span class="nav-text">部分信号一览</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E7%9A%845%E7%A7%8D%E9%BB%98%E8%AE%A4%E5%A4%84%E7%90%86%E5%8A%A8%E4%BD%9C"><span class="nav-number">6.6.2.</span> <span class="nav-text">信号的5种默认处理动作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E7%9B%B8%E5%85%B3%E7%9A%84%E5%87%BD%E6%95%B0"><span class="nav-number">6.6.3.</span> <span class="nav-text">信号相关的函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#signal%E4%BF%A1%E5%8F%B7%E6%8D%95%E6%8D%89"><span class="nav-number">6.6.4.</span> <span class="nav-text">signal信号捕捉</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%9B%86%E5%8F%8A%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="nav-number">6.7.</span> <span class="nav-text">信号集及相关函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%9B%86"><span class="nav-number">6.7.1.</span> <span class="nav-text">信号集</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="nav-number">6.7.2.</span> <span class="nav-text">相关函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B"><span class="nav-number">6.7.3.</span> <span class="nav-text">信号处理过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sigprocmask%E5%87%BD%E6%95%B0"><span class="nav-number">6.7.4.</span> <span class="nav-text">sigprocmask函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sigaction%E4%BF%A1%E5%8F%B7%E6%8D%95%E6%8D%89%E5%87%BD%E6%95%B0"><span class="nav-number">6.7.5.</span> <span class="nav-text">sigaction信号捕捉函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SIGCHLD%E4%BF%A1%E5%8F%B7"><span class="nav-number">6.7.6.</span> <span class="nav-text">SIGCHLD信号</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98"><span class="nav-number">6.8.</span> <span class="nav-text">共享内存</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4"><span class="nav-number">6.8.1.</span> <span class="nav-text">共享内存使用步骤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E5%92%8C%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">6.8.2.</span> <span class="nav-text">共享内存和内存映射的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4"><span class="nav-number">6.8.3.</span> <span class="nav-text">共享内存操作命令</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B"><span class="nav-number">6.9.</span> <span class="nav-text">守护进程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%88%E7%AB%AF"><span class="nav-number">6.9.1.</span> <span class="nav-text">终端</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%BB%84"><span class="nav-number">6.9.2.</span> <span class="nav-text">进程组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%9A%E8%AF%9D"><span class="nav-number">6.9.3.</span> <span class="nav-text">会话</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%BB%84%E3%80%81%E4%BC%9A%E8%AF%9D%E3%80%81%E6%8E%A7%E5%88%B6%E7%BB%88%E7%AB%AF%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">6.9.4.</span> <span class="nav-text">进程组、会话、控制终端之间的关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%BB%84%E3%80%81%E4%BC%9A%E8%AF%9D%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0"><span class="nav-number">6.9.5.</span> <span class="nav-text">进程组、会话操作函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B-1"><span class="nav-number">6.9.6.</span> <span class="nav-text">守护进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E6%AD%A5%E9%AA%A4"><span class="nav-number">6.9.7.</span> <span class="nav-text">守护进程的创建步骤</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="MoChen"
      src="https://hexo-blog-1254337849.cos.na-ashburn.myqcloud.com/WechatIMG93.jpeg">
  <p class="site-author-name" itemprop="name">MoChen</p>
  <div class="site-description" itemprop="description">临渊羡鱼，不如退而结网</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">13</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/745698140" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;745698140" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:nikolaschen@qq.com" title="E-Mail → mailto:nikolaschen@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">MoChen</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
