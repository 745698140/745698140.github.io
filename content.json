{"meta":{"title":"MoChen's","subtitle":"","description":"临渊羡鱼，不如退而结网","author":"MoChen","url":"http://yoursite.com","root":"/"},"pages":[{"title":"tags","date":"2020-08-23T14:01:22.000Z","updated":"2020-08-23T14:09:32.600Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"C++中的顶层const和底层const","slug":"C++中的顶层const和底层const","date":"2020-09-01T10:40:27.000Z","updated":"2020-09-21T14:32:33.323Z","comments":true,"path":"2020/09/01/C++中的顶层const和底层const/","link":"","permalink":"http://yoursite.com/2020/09/01/C++%E4%B8%AD%E7%9A%84%E9%A1%B6%E5%B1%82const%E5%92%8C%E5%BA%95%E5%B1%82const/","excerpt":"​ const对象一旦创建后其值就不能再改变。而对于指针这种本身是一个对象，它又可以指向另一个对象的情况时，指针本身是不是常量以及指针所指的是不是一个常量就是两个相互独立的问题了，用名词顶层const(top-level const)表示指针本身是个常量，而用底层const(low-level const)表示指针所指的对象是一个常量。","text":"​ const对象一旦创建后其值就不能再改变。而对于指针这种本身是一个对象，它又可以指向另一个对象的情况时，指针本身是不是常量以及指针所指的是不是一个常量就是两个相互独立的问题了，用名词顶层const(top-level const)表示指针本身是个常量，而用底层const(low-level const)表示指针所指的对象是一个常量。 top-level const 的一些演示1234567//初始化两个非常量int i1 = 20; int i2 = 30;//初始化一个顶层const指针，这个操作意味着指针本身的值是一个常量，其本身是不可以改变的，而指针所指的值是一个非常量是可以改变的int *const p = &amp;i1;p = &amp;i2; //错误。指针p本身是一个常量，是不可以改变的*p = i2; //正确。指针所指的值并不是一个常量，是可以改变的 low-level const 的一些演示1234567//初始化两个非常量int i1 = 20;int i2 = 30;//初始化一个底层const指针，这个操作意味着这个指针指向一个常量，不可以通过该指针去改变指针所指的对象，但指针本身是可以更改的const int *p = &amp;i1;*p = i2; //错误。指针p所指的是一个常量，不可以通过指针去修改其指向的对象p = &amp;i2; //正确。指针本身不是常量，可以修改指针本身 ​ 上面的展示应该很清楚地展示了顶层const和底层const的区别所在，当然我们也可以将一个指针声明为既是底层cosnt亦是顶层const，这样我们就不可以通过指针去修改指针所指的对象，也不可以修改指针本身，其声明方式如下。 1234567//初始化两个非常量int i1 = 20;int i2 = 30;//初始化一个既是底层const也是顶层const的指针const int *const p = &amp;i1;*p = i2; //错误。指针p是一个底层const，其所指的对象是一个常量。p = &amp;i2; //错误。指针p是一个顶层const，其本身是一个常量。 所谓的指向常量的指针(pointer to const)只是指针自己以为自己指向的是常量​ 为什么上面的例子都是初始化两个非常量呢？因为其实对于指向常量的指针来说（意思是底层const），只是指针自以为自己指向的是一个常量，所以指针自觉地不去改变所指的对象。但其实指向常量的指针没有规定其所指的对象必须是一个常量。 12345678//初始化两个非常量int i1 = 20;int i2 = 30;//初始化一个底层const指针，即指向常量的指针const int *p = &amp;i1;*p = i2; //错误。指针认为自己指向的是常量，不能通过自己去改变所指的对象i1 = i2; //正确。指向常量的指针没有规定所指的对象是一个常量，所以可以直接修改非常量对象本身std::cout &lt;&lt; *p; //将会打印&quot;30&quot;，而不是&quot;20&quot; 指针和constexpr​ C++11中，允许将变量声明为constexpr类型以便由编译器来验证变量的值是否是一个常量表达式。但必须明确一点，在constexpr声明中如果定义了一个指针，限定符constexpr仅对指针有效，与指针所指的对象无关。意思就是通过constexpr定义的指针是一个顶层const。 1234constexpr int i = 20; //定义一个常量int j = 100; //定义一个非常量constexpr int *p = &amp;i; //错误。p本身是一个常量，但p所指的不是一个常量，所以p不能指向一个常量整数constexpr int *p = &amp;j; //正确。p本身是一个常量指针，指向一个整数","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"对KMP算法的一些理解","slug":"对KMP算法的一些理解","date":"2020-08-24T01:14:10.000Z","updated":"2020-08-29T13:07:55.033Z","comments":true,"path":"2020/08/24/对KMP算法的一些理解/","link":"","permalink":"http://yoursite.com/2020/08/24/%E5%AF%B9KMP%E7%AE%97%E6%B3%95%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/","excerpt":"KMP算法是一种字符串匹配算法，可以在O(n+m)时间复杂度内实现两个字符串的匹配。","text":"KMP算法是一种字符串匹配算法，可以在O(n+m)时间复杂度内实现两个字符串的匹配。 关于字符串匹配暴力解决字符串匹配即通过两个串的每个字符逐一比较，python实现如下： 1234def match(S, P): for i in range(len(S) - len(P) + 1): if S[i:i+len(P)] == P: return i 如果 n = len(S), m = len(P)。那么最坏的情况下，暴力解法的时间复杂度能去到O(nm)。 暴力解法并没有利用字符串匹配过程中残留的一部分信息，而KMP算法则是通过“尽可能减少比较的趟数”来做到优化，即看看能否在匹配失败后，跳过一部分不可能成功的字符串比较来使复杂度降低。 简述KMP起始思路","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/tags/algorithm/"}]},{"title":"vimKeyboard","slug":"vimKeyboard","date":"2020-08-23T13:19:30.000Z","updated":"2020-08-23T13:19:30.000Z","comments":true,"path":"2020/08/23/vimKeyboard/","link":"","permalink":"http://yoursite.com/2020/08/23/vimKeyboard/","excerpt":"","text":"vim键位图","categories":[],"tags":[{"name":"vim","slug":"vim","permalink":"http://yoursite.com/tags/vim/"}]}],"categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/tags/algorithm/"},{"name":"vim","slug":"vim","permalink":"http://yoursite.com/tags/vim/"}]}