{"meta":{"title":"MoChen's","subtitle":"","description":"临渊羡鱼，不如退而结网","author":"MoChen","url":"http://yoursite.com","root":"/"},"pages":[{"title":"tags","date":"2020-08-23T14:01:22.000Z","updated":"2020-08-23T14:09:32.600Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"重载、重写（覆盖）、隐藏的区别","slug":"重载、重写（覆盖）、隐藏的区别","date":"2021-03-20T21:53:30.000Z","updated":"2021-03-20T22:04:09.373Z","comments":true,"path":"2021/03/20/重载、重写（覆盖）、隐藏的区别/","link":"","permalink":"http://yoursite.com/2021/03/20/%E9%87%8D%E8%BD%BD%E3%80%81%E9%87%8D%E5%86%99%EF%BC%88%E8%A6%86%E7%9B%96%EF%BC%89%E3%80%81%E9%9A%90%E8%97%8F%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"概念解释 重载：是指同一可访问区内被声明几个具有不同参数列（参数的类型、个数、顺序）的同名函数，根据参数列表确定调用哪个函数，重载不关心函数返回类型。","text":"概念解释 重载：是指同一可访问区内被声明几个具有不同参数列（参数的类型、个数、顺序）的同名函数，根据参数列表确定调用哪个函数，重载不关心函数返回类型。 隐藏：是指派生类的函数屏蔽了与其同名的基类函数，主要只要同名函数，不管参数列表是否相同，基类函数都会被隐藏。 重写（覆盖）：是指派生类中存在重新定义的函数。函数名、参数列表、返回值类型都必须同基类中被重写的函数一致，只有函数体不同。派生类调用时会调用派生类的重写函数，不会调用被重写函数。重写的基类中被重写的函数必须有 virtual 修饰。 重写和重载的区别： 范围区别：对于类中函数的重载或者重写而言，重载发生在同一个类的内部，重写发生在不同的类之间。 参数区别：重载的函数需要与原函数有相同的函数名、不同的参数列表，不关心函数的返回值类型；重写的函数的函数名、参数列表和返回值类型都需要与原函数相同，父类中被重写的函数需要有 virtual 修饰。 virtual 关键字：重写的函数基类中必须有 virtual 关键字的修饰，重载的函数可以有 virtual 关键字的修饰也可以没有。 隐藏和重写，重载的区别： 范围区别：隐藏发生在不同类中。 参数区别：隐藏函数和被隐藏函数只需要函数名相同；当参数不同时，无论基类中的函数是否被 virtual 修饰，基类函数都是被隐藏，而不是重写。","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"weak_ptr是如何解决循环引用的","slug":"weak_ptr是如何解决循环引用的","date":"2021-03-20T11:54:24.000Z","updated":"2021-03-20T21:40:59.925Z","comments":true,"path":"2021/03/20/weak_ptr是如何解决循环引用的/","link":"","permalink":"http://yoursite.com/2021/03/20/weak_ptr%E6%98%AF%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E7%9A%84/","excerpt":"C++11中智能指针包括三种：共享指针(shared_ptr)，独占指针(unique_ptr)，弱指针(weak_ptr)。 智能指针通过计数原理来实现，但在使用过程中可能会出现循环引用的问题，我们可以通过weak_ptr去解决。","text":"C++11中智能指针包括三种：共享指针(shared_ptr)，独占指针(unique_ptr)，弱指针(weak_ptr)。 智能指针通过计数原理来实现，但在使用过程中可能会出现循环引用的问题，我们可以通过weak_ptr去解决。 出现循环引用的举例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt;#include &lt;memory&gt;using namespace std;class Child;class Parent;class Parent &#123;private: shared_ptr&lt;Child&gt; ChildPtr;public: void setChild(shared_ptr&lt;Child&gt; child) &#123; this-&gt;ChildPtr = child; &#125; void doSomething() &#123; if (this-&gt;ChildPtr.use_count()) &#123; &#125; &#125; ~Parent() &#123; &#125;&#125;;class Child &#123;private: shared_ptr&lt;Parent&gt; ParentPtr;public: void setPartent(shared_ptr&lt;Parent&gt; parent) &#123; this-&gt;ParentPtr = parent; &#125; void doSomething() &#123; if (this-&gt;ParentPtr.use_count()) &#123; &#125; &#125; ~Child() &#123; &#125;&#125;;int main() &#123; weak_ptr&lt;Parent&gt; wpp; weak_ptr&lt;Child&gt; wpc; &#123; shared_ptr&lt;Parent&gt; p(new Parent); shared_ptr&lt;Child&gt; c(new Child); p-&gt;setChild(c); c-&gt;setPartent(p); wpp = p; wpc = c; cout &lt;&lt; p.use_count() &lt;&lt; endl; // 2 cout &lt;&lt; c.use_count() &lt;&lt; endl; // 2 &#125; cout &lt;&lt; wpp.use_count() &lt;&lt; endl; // 1 cout &lt;&lt; wpc.use_count() &lt;&lt; endl; // 1 return 0;&#125; 在如下例子中定义了两个类 Parent、Child，在两个类中分别定义另一个类的对象的共享指针，由于在程序结束后，两个指针相互指向对方的内存空间，导致内存无法释放。 使用weak_ptr解决循环引用因为weak_ptr的作用是绑定到一个智能指针上，但不会影响该指针的计数，所以我们只需要在原本的循环引用中，令其中一环为weak_ptr即可打破这个闭环。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#include &lt;memory&gt;using namespace std;class Child;class Parent;class Parent &#123;private: //shared_ptr&lt;Child&gt; ChildPtr; weak_ptr&lt;Child&gt; ChildPtr;public: void setChild(shared_ptr&lt;Child&gt; child) &#123; this-&gt;ChildPtr = child; &#125; void doSomething() &#123; //new shared_ptr if (this-&gt;ChildPtr.lock()) &#123; &#125; &#125; ~Parent() &#123; &#125;&#125;;class Child &#123;private: shared_ptr&lt;Parent&gt; ParentPtr;public: void setPartent(shared_ptr&lt;Parent&gt; parent) &#123; this-&gt;ParentPtr = parent; &#125; void doSomething() &#123; if (this-&gt;ParentPtr.use_count()) &#123; &#125; &#125; ~Child() &#123; &#125;&#125;;int main() &#123; weak_ptr&lt;Parent&gt; wpp; weak_ptr&lt;Child&gt; wpc; &#123; shared_ptr&lt;Parent&gt; p(new Parent); shared_ptr&lt;Child&gt; c(new Child); p-&gt;setChild(c); c-&gt;setPartent(p); wpp = p; wpc = c; cout &lt;&lt; p.use_count() &lt;&lt; endl; // 2 cout &lt;&lt; c.use_count() &lt;&lt; endl; // 1 &#125; cout &lt;&lt; wpp.use_count() &lt;&lt; endl; // 0 cout &lt;&lt; wpc.use_count() &lt;&lt; endl; // 0 return 0;&#125; 为什么在访问weak_ptr所指的对象时，要先转为shared_ptr?","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"指针","slug":"指针","permalink":"http://yoursite.com/tags/%E6%8C%87%E9%92%88/"},{"name":"智能指针","slug":"智能指针","permalink":"http://yoursite.com/tags/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"}]},{"title":"C++内存管理及栈、堆区别","slug":"C++内存管理及栈、堆区别","date":"2021-03-20T09:54:45.000Z","updated":"2021-03-20T10:08:37.719Z","comments":true,"path":"2021/03/20/C++内存管理及栈、堆区别/","link":"","permalink":"http://yoursite.com/2021/03/20/C++%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%8F%8A%E6%A0%88%E3%80%81%E5%A0%86%E5%8C%BA%E5%88%AB/","excerpt":"C++内存分区 栈：存放函数的局部变量、函数参数、返回地址等，由编译器自动分配 堆：动态申请的内存空间，就是由malloc分配的内存块，由程序员控制它的分配和释放，如果程序结束还没有释放，操作系统会自动回收","text":"C++内存分区 栈：存放函数的局部变量、函数参数、返回地址等，由编译器自动分配 堆：动态申请的内存空间，就是由malloc分配的内存块，由程序员控制它的分配和释放，如果程序结束还没有释放，操作系统会自动回收 全局区/静态存储区（.bss段和.data段）：存放全局变量和静态变量，程序运行结束操作系统自动释放 常量存储区：存放的是常量，不允许修改，程序运行结束自动释放 代码区：存放代码，不允许修改，但可以执行。编译后的二进制文件存放在这里 栈和堆的区别 申请方式：栈是系统自动分配，堆是程序员主动申请 申请后系统响应：分配栈空间，如果剩余空间大于申请空间则分配成功，否则分配失败栈溢出；申请堆空间，堆在内存中呈现方式类似于链表（记录空闲地址空间的链表），在链表上寻找第一个大于申请空间的节点分配给程序，将该节点从链表中删除，大多数系统中该块空间的首地址存放的是本次分配空间的大小，便于释放，将该块空间上的剩余空间再次连接在空闲链表上。 栈在内存中是连续的一块空间（向低地址扩展）最大容量是系统预定好的，堆在内存中的空间（向高地址扩展）是不连续的。 申请效率：栈是由系统自动分配，申请效率高，但程序员无法控制；堆是由程序员自己来申请的，效率低，容易产生碎片。 存放的内容：栈中存放的是局部变量，函数的参数；堆中存放的内容由程序员控制。","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"C++类对象的初始化顺序","slug":"C++类对象的初始化顺序","date":"2021-03-19T23:28:20.000Z","updated":"2021-03-19T23:34:55.118Z","comments":true,"path":"2021/03/19/C++类对象的初始化顺序/","link":"","permalink":"http://yoursite.com/2021/03/19/C++%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F/","excerpt":"构造函数调用顺序： 按照派生类继承基类的顺序，即派生列表中声明的顺序，依次调用基类的构造函数； 按照派生类中成员变量的声明顺序，依次调用派生类中成员变量所属类的构造函数； 执行派生类自身的构造函数。","text":"构造函数调用顺序： 按照派生类继承基类的顺序，即派生列表中声明的顺序，依次调用基类的构造函数； 按照派生类中成员变量的声明顺序，依次调用派生类中成员变量所属类的构造函数； 执行派生类自身的构造函数。 综上可知，类对象的初始化顺序：基类构造函数-&gt;派生类成员变量的构造函数-&gt;自身构造函数。 基类构造函数的调用顺序与派生类的派生列表的顺序有关； 成员变量的初始化顺序与声明顺序有关； 析构顺序和构造顺序相反。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;using namespace std;class A&#123;public: A() &#123; cout &lt;&lt; &quot;A()&quot; &lt;&lt; endl; &#125; ~A() &#123; cout &lt;&lt; &quot;~A()&quot; &lt;&lt; endl; &#125;&#125;;class B&#123;public: B() &#123; cout &lt;&lt; &quot;B()&quot; &lt;&lt; endl; &#125; ~B() &#123; cout &lt;&lt; &quot;~B()&quot; &lt;&lt; endl; &#125;&#125;;class Test : public A, public B // 派生列表&#123;public: Test() &#123; cout &lt;&lt; &quot;Test()&quot; &lt;&lt; endl; &#125; ~Test() &#123; cout &lt;&lt; &quot;~Test()&quot; &lt;&lt; endl; &#125;private: B ex1; A ex2;&#125;;int main()&#123; Test ex; return 0;&#125;/*运行结果：A()B()B()A()Test()~Test()~A()~B()~B()~A()*/","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"类","slug":"类","permalink":"http://yoursite.com/tags/%E7%B1%BB/"}]},{"title":"C++的构造函数为什么不能是虚函数，而基类的析构函数必须是虚函数","slug":"C++的构造函数为什么不能是虚函数，而基类的析构函数必须是虚函数","date":"2021-03-19T22:08:59.000Z","updated":"2021-03-19T22:30:00.192Z","comments":true,"path":"2021/03/19/C++的构造函数为什么不能是虚函数，而基类的析构函数必须是虚函数/","link":"","permalink":"http://yoursite.com/2021/03/19/C++%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E6%98%AF%E8%99%9A%E5%87%BD%E6%95%B0%EF%BC%8C%E8%80%8C%E5%9F%BA%E7%B1%BB%E7%9A%84%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E5%BF%85%E9%A1%BB%E6%98%AF%E8%99%9A%E5%87%BD%E6%95%B0/","excerpt":"构造函数为什么不能是虚函数呢？首先我们需要知道两个概念，以及这两者之间的关联： 虚表指针vptr 虚函数表","text":"构造函数为什么不能是虚函数呢？首先我们需要知道两个概念，以及这两者之间的关联： 虚表指针vptr 虚函数表 vptr指针指向虚函数表，执行虚函数的时候，会调用vptr指针指向的虚函数的地址。 当定义一个对象的时候，首先会分配对象内存空间，然后调用构造函数来初始化对象。vptr变量是在构造函数中进行初始化的。又因为执行虚函数需要通过vptr指针来调用。如果可以定义构造函数为虚函数，那么这将陷入死锁。 基类的析构函数为什么必须是虚函数呢？我们想要回收一个对象申请的资源，就需要调用析构函数。虽然我们没有显示调用析构函数，但是编译器会默认地为我们执行析构函数。 那么当我们执行 BaseClass *base = new BaseClass(); 当我们执行 delete base 时，会调用析构函数为我们释放资源。而我们执行 BaseClass *sub = new SubClass(); 如果BaseClass基类的析构函数不是虚函数的时候，delete sub 对象的时候，只会释放 BaseClass 基类申请的资源，而不是释放 SubClass 派生类的资源，原因如下： 基类指针指向了派生类对象，而基类中的析构函数是非virtual的，而虚函数是动态绑定的基础。现在析构函数不是virtual的，因此不会发生动态绑定，而是静态绑定，指针的静态类型为基类指针，因此在delete的时候只会调用基类的析构函数，而不会调用派生类的析构函数。这样，在派生类中申请的资源就不会得到释放，就会造成内存泄漏。","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"虚函数","slug":"虚函数","permalink":"http://yoursite.com/tags/%E8%99%9A%E5%87%BD%E6%95%B0/"}]},{"title":"Python time, random, collections, itertools基本用法","slug":"Python-time-random-collections-itertools基本用法","date":"2020-10-28T11:35:26.000Z","updated":"2020-10-28T11:40:02.995Z","comments":true,"path":"2020/10/28/Python-time-random-collections-itertools基本用法/","link":"","permalink":"http://yoursite.com/2020/10/28/Python-time-random-collections-itertools%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/","excerpt":"Python time, random, collections, itertools 的基本用法","text":"Python time, random, collections, itertools 的基本用法 time库import time Python处理时间的标准库 time.localtime() 本地时间 time.gmtime() UTC世界统一时间，北京时间比这个统一时间早8个小时 time.ctime() 返回本地时间的字符串 时间戳和计时器 time.time() 返回自纪元以来的秒数，记录time.sleep() time.perf_counter() 随意取一个时间点到该时间点的间隔秒数，记录sleep time.process_time() 随意取，不记录sleep 格式化time.strftime自定义格式化输出 12lctime = time.localtime()time.strftime(&quot;%Y-%m-%d %A %H:%M:%S&quot;, lctime) sleeptime.sleep() 以秒为单位 random库Python通过random库提供各种伪随机数 随机种子——seed(a=None) 相同的种子会产生相同的随机数 如果不设置随机种子，以系统当前时间为默认值 产生随机整数 randint(a, b) 产生[a,b]之间 randrange(a) 产生[0,a) randrange(a, b, step) 产生[a, b), 以step为步长 产生随机浮点数 random() 产生[0.0,1.0) uniform(a, b) 产生[a, b] 序列用函数 choice(seq) 从seq返回一个 choices(seq, weights=None, k) 对seq进行k次，可设置权重 shuffle(seq) 将seq随机排列 sample(pop, k) 从pop中随机可，以列表返回，k不能超过len(pop) 概率分布guess(mean, std) collecitons库import collecitons nametuplecollecitons.nametuple(typename, field_names, *, rename=False, default=None, module=None) 12345678910Point = collecitons.nametuple(&quot;Point&quot;, [&quot;x&quot;, &quot;y&quot;])p = Point(1, y=2)p # Point(x=1, y=2)# 可以调用属性print(p.x) # 1# 有元组的性质print(p[0]) # 1x, y = pprint(x) # 1 Counterfrom collecitons import Counter 计数统计 Counter.most_common(n) 最常见的n个 Counter.elements() 展开 deque双向队列 append() appendleft() pop() popleft() itertools库排列组合迭代器 product——笛卡尔积 product(‘ABC’, “01”) product(‘ABC’, repeat = 3) permutations——排列 permutations(range(3)) combinations——组合 combinations(‘abcd’, 2) combinations(range(4), 3) combinations_with_replacement——元素可重复组合 拉链 zip——短拉链 zip(‘abc’, ‘012’, ‘xyz’) 长度不一时，执行到最短的对象处就停止 zip_longest——长拉链 zip_longest(‘abc’, ‘012345’, fillvalue=”?”) 长度不一时，执行到最长的对象处就停止，缺省元素用None或指定的字符替代 无穷迭代器 count(start=0, step=1) 计数 cycle(iterable) 循环 repeat(object, times) 重复 chain(iterables) 锁链 enumerate(iterable, start=0)——枚举（内置） 产出有两个元素组成的元组， 结构式(index, item)，其中index从start开始，item从iterable中取 12for i in enumerate(&quot;pyhton&quot;, start = 1): print(i) groupby(iterable, key=None)——分组 创建一个迭代器，按照key指定的方式，返回iterable中连续的键和组，一般来说要预先对数据进行排序，key为None默认把连续重复元素分组","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"算法中的差分思想","slug":"算法中的差分思想","date":"2020-09-21T14:48:59.000Z","updated":"2020-09-21T14:48:59.343Z","comments":true,"path":"2020/09/21/算法中的差分思想/","link":"","permalink":"http://yoursite.com/2020/09/21/%E7%AE%97%E6%B3%95%E4%B8%AD%E7%9A%84%E5%B7%AE%E5%88%86%E6%80%9D%E6%83%B3/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"C++中的const成员函数","slug":"C++中的const成员函数","date":"2020-09-21T14:43:13.000Z","updated":"2020-10-01T11:18:08.673Z","comments":true,"path":"2020/09/21/C++中的const成员函数/","link":"","permalink":"http://yoursite.com/2020/09/21/C++%E4%B8%AD%E7%9A%84const%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/","excerpt":"我们在定义类的成员函数的时候，往往函数块内会返回一个其他的成员，这种方式实际上是隐式地指向调用该函数的对象的成员，即成员函数通过一个名为this的额外的隐式参数来访问调用它的那个对象。 而我们往往会看到成员函数的参数列表后紧跟着一个const关键字，这个const的作用是修改隐式this指针的类型。","text":"我们在定义类的成员函数的时候，往往函数块内会返回一个其他的成员，这种方式实际上是隐式地指向调用该函数的对象的成员，即成员函数通过一个名为this的额外的隐式参数来访问调用它的那个对象。 而我们往往会看到成员函数的参数列表后紧跟着一个const关键字，这个const的作用是修改隐式this指针的类型。 默认情况下来说，this的类型是指向类类型的非常量版本的指针，可以表示为 struct_name *const, 尽管this是隐式的，但它仍需要遵循初始化原则，这就意味值默认情况下this指针是不能绑定到一个常量对象上的，这也就意味着我们不能在一个常量对象上调用普通成员函数。 123456789101112131415161718// 简单定义一个类struct help&#123; int a; int b; help(int aa, int bb) &#123; a = aa; b = bb; &#125; int helper() &#123; return a; &#125;&#125;;int main(int argc, const char * argv[]) &#123; const help temp(12, 23); // 声明一个常量类对象 int c = temp.helper(); // 错误，因为help()是一个普通成员函数，所以this是指向一个非常量对象，而temp又是一个常量对象，所以会报错 cout &lt;&lt; c &lt;&lt; endl;&#125; 所以在这种情况下，我们应该把this声明为 const struct_name *const 这样就可以解决问题，但又因为this是隐式的，所以我们可以将成员函数的声明改为： 1int helper() const &#123;&#125; 这样就可以将this声明为指向常量对象的版本了。而这种使用const的成员函数也叫做常量成员函数(const member function)。","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"C++中的顶层const和底层const","slug":"C++中的顶层const和底层const","date":"2020-09-01T10:40:27.000Z","updated":"2020-09-21T14:52:36.222Z","comments":true,"path":"2020/09/01/C++中的顶层const和底层const/","link":"","permalink":"http://yoursite.com/2020/09/01/C++%E4%B8%AD%E7%9A%84%E9%A1%B6%E5%B1%82const%E5%92%8C%E5%BA%95%E5%B1%82const/","excerpt":"​ const对象一旦创建后其值就不能再改变。而对于指针这种本身是一个对象，它又可以指向另一个对象的情况时，指针本身是不是常量以及指针所指的是不是一个常量就是两个相互独立的问题了，用名词顶层const(top-level const)表示指针本身是个常量，而用底层const(low-level const)表示指针所指的对象是一个常量。","text":"​ const对象一旦创建后其值就不能再改变。而对于指针这种本身是一个对象，它又可以指向另一个对象的情况时，指针本身是不是常量以及指针所指的是不是一个常量就是两个相互独立的问题了，用名词顶层const(top-level const)表示指针本身是个常量，而用底层const(low-level const)表示指针所指的对象是一个常量。 top-level const 的一些演示1234567//初始化两个非常量int i1 = 20; int i2 = 30;//初始化一个顶层const指针，这个操作意味着指针本身的值是一个常量，其本身是不可以改变的，而指针所指的值是一个非常量是可以改变的int *const p = &amp;i1;p = &amp;i2; //错误。指针p本身是一个常量，是不可以改变的*p = i2; //正确。指针所指的值并不是一个常量，是可以改变的 low-level const 的一些演示1234567//初始化两个非常量int i1 = 20;int i2 = 30;//初始化一个底层const指针，这个操作意味着这个指针指向一个常量，不可以通过该指针去改变指针所指的对象，但指针本身是可以更改的const int *p = &amp;i1;*p = i2; //错误。指针p所指的是一个常量，不可以通过指针去修改其指向的对象p = &amp;i2; //正确。指针本身不是常量，可以修改指针本身 ​ 上面的展示应该很清楚地展示了顶层const和底层const的区别所在，当然我们也可以将一个指针声明为既是底层cosnt亦是顶层const，这样我们就不可以通过指针去修改指针所指的对象，也不可以修改指针本身，其声明方式如下。 1234567//初始化两个非常量int i1 = 20;int i2 = 30;//初始化一个既是底层const也是顶层const的指针const int *const p = &amp;i1;*p = i2; //错误。指针p是一个底层const，其所指的对象是一个常量。p = &amp;i2; //错误。指针p是一个顶层const，其本身是一个常量。 所谓的指向常量的指针(pointer to const)只是指针自己以为自己指向的是常量​ 为什么上面的例子都是初始化两个非常量呢？因为其实对于指向常量的指针来说（意思是底层const），只是指针自以为自己指向的是一个常量，所以指针自觉地不去改变所指的对象。但其实指向常量的指针没有规定其所指的对象必须是一个常量。 12345678//初始化两个非常量int i1 = 20;int i2 = 30;//初始化一个底层const指针，即指向常量的指针const int *p = &amp;i1;*p = i2; //错误。指针认为自己指向的是常量，不能通过自己去改变所指的对象i1 = i2; //正确。指向常量的指针没有规定所指的对象是一个常量，所以可以直接修改非常量对象本身std::cout &lt;&lt; *p; //将会打印&quot;30&quot;，而不是&quot;20&quot; 指针和constexpr​ C++11中，允许将变量声明为constexpr类型以便由编译器来验证变量的值是否是一个常量表达式。但必须明确一点，在constexpr声明中如果定义了一个指针，限定符constexpr仅对指针有效，与指针所指的对象无关。意思就是通过constexpr定义的指针是一个顶层const。 1234constexpr int i = 20; //定义一个常量int j = 100; //定义一个非常量constexpr int *p = &amp;i; //错误。p本身是一个常量，但p所指的不是一个常量，所以p不能指向一个常量整数constexpr int *p = &amp;j; //正确。p本身是一个常量指针，指向一个整数","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"指针","slug":"指针","permalink":"http://yoursite.com/tags/%E6%8C%87%E9%92%88/"},{"name":"const","slug":"const","permalink":"http://yoursite.com/tags/const/"}]},{"title":"对KMP算法的一些理解","slug":"对KMP算法的一些理解","date":"2020-08-24T01:14:10.000Z","updated":"2020-08-29T13:07:55.033Z","comments":true,"path":"2020/08/24/对KMP算法的一些理解/","link":"","permalink":"http://yoursite.com/2020/08/24/%E5%AF%B9KMP%E7%AE%97%E6%B3%95%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/","excerpt":"KMP算法是一种字符串匹配算法，可以在O(n+m)时间复杂度内实现两个字符串的匹配。","text":"KMP算法是一种字符串匹配算法，可以在O(n+m)时间复杂度内实现两个字符串的匹配。 关于字符串匹配暴力解决字符串匹配即通过两个串的每个字符逐一比较，python实现如下： 1234def match(S, P): for i in range(len(S) - len(P) + 1): if S[i:i+len(P)] == P: return i 如果 n = len(S), m = len(P)。那么最坏的情况下，暴力解法的时间复杂度能去到O(nm)。 暴力解法并没有利用字符串匹配过程中残留的一部分信息，而KMP算法则是通过“尽可能减少比较的趟数”来做到优化，即看看能否在匹配失败后，跳过一部分不可能成功的字符串比较来使复杂度降低。 简述KMP起始思路","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/tags/algorithm/"}]},{"title":"vimKeyboard","slug":"vimKeyboard","date":"2020-08-23T13:19:30.000Z","updated":"2020-08-23T13:19:30.000Z","comments":true,"path":"2020/08/23/vimKeyboard/","link":"","permalink":"http://yoursite.com/2020/08/23/vimKeyboard/","excerpt":"","text":"vim键位图","categories":[],"tags":[{"name":"vim","slug":"vim","permalink":"http://yoursite.com/tags/vim/"}]}],"categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"指针","slug":"指针","permalink":"http://yoursite.com/tags/%E6%8C%87%E9%92%88/"},{"name":"智能指针","slug":"智能指针","permalink":"http://yoursite.com/tags/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"},{"name":"类","slug":"类","permalink":"http://yoursite.com/tags/%E7%B1%BB/"},{"name":"虚函数","slug":"虚函数","permalink":"http://yoursite.com/tags/%E8%99%9A%E5%87%BD%E6%95%B0/"},{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"},{"name":"const","slug":"const","permalink":"http://yoursite.com/tags/const/"},{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/tags/algorithm/"},{"name":"vim","slug":"vim","permalink":"http://yoursite.com/tags/vim/"}]}