{"meta":{"title":"MoChen's","subtitle":"","description":"临渊羡鱼，不如退而结网","author":"MoChen","url":"http://yoursite.com","root":"/"},"pages":[{"title":"tags","date":"2020-08-23T14:01:22.000Z","updated":"2020-08-23T14:09:32.600Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"C++的构造函数为什么不能是虚函数，而基类的析构函数必须是虚函数","slug":"C++的构造函数为什么不能是虚函数，而基类的析构函数必须是虚函数","date":"2021-03-19T22:08:59.000Z","updated":"2021-03-19T22:25:17.161Z","comments":true,"path":"2021/03/19/C++的构造函数为什么不能是虚函数，而基类的析构函数必须是虚函数/","link":"","permalink":"http://yoursite.com/2021/03/19/C++%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E6%98%AF%E8%99%9A%E5%87%BD%E6%95%B0%EF%BC%8C%E8%80%8C%E5%9F%BA%E7%B1%BB%E7%9A%84%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E5%BF%85%E9%A1%BB%E6%98%AF%E8%99%9A%E5%87%BD%E6%95%B0/","excerpt":"","text":"构造函数为什么不能是虚函数呢？首先我们需要知道两个概念，以及这两者之间的关联： 虚表指针vptr 虚函数表 vptr指针指向虚函数表，执行虚函数的时候，会调用vptr指针指向的虚函数的地址。 当定义一个对象的时候，首先会分配对象内存空间，然后调用构造函数来初始化对象。vptr变量是在构造函数中进行初始化的。又因为执行虚函数需要通过vptr指针来调用。如果可以定义构造函数为虚函数，那么这将陷入死锁。 基类的析构函数为什么必须是虚函数呢？我们想要回收一个对象申请的资源，就需要调用析构函数。虽然我们没有显示调用析构函数，但是编译器会默认地为我们执行析构函数。 那么当我们执行 BaseClass *base = new BaseClass(); 当我们执行 delete base 时，会调用析构函数为我们释放资源。而我们执行 BaseClass *sub = new SubClass(); 如果BaseClass基类的析构函数不是虚函数的时候，delete sub 对象的时候，只会释放 BaseClass 基类申请的资源，而不是释放 SubClass 派生类的资源，原因如下： 基类指针指向了派生类对象，而基类中的析构函数是非virtual的，而虚函数是动态绑定的基础。现在析构函数不是virtual的，因此不会发生动态绑定，而是静态绑定，指针的静态类型为基类指针，因此在delete的时候只会调用基类的析构函数，而不会调用派生类的析构函数。这样，在派生类中申请的资源就不会得到释放，就会造成内存泄漏。","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"虚函数","slug":"虚函数","permalink":"http://yoursite.com/tags/%E8%99%9A%E5%87%BD%E6%95%B0/"}]},{"title":"Python time, random, collections, itertools基本用法","slug":"Python-time-random-collections-itertools基本用法","date":"2020-10-28T11:35:26.000Z","updated":"2020-10-28T11:40:02.995Z","comments":true,"path":"2020/10/28/Python-time-random-collections-itertools基本用法/","link":"","permalink":"http://yoursite.com/2020/10/28/Python-time-random-collections-itertools%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/","excerpt":"Python time, random, collections, itertools 的基本用法","text":"Python time, random, collections, itertools 的基本用法 time库import time Python处理时间的标准库 time.localtime() 本地时间 time.gmtime() UTC世界统一时间，北京时间比这个统一时间早8个小时 time.ctime() 返回本地时间的字符串 时间戳和计时器 time.time() 返回自纪元以来的秒数，记录time.sleep() time.perf_counter() 随意取一个时间点到该时间点的间隔秒数，记录sleep time.process_time() 随意取，不记录sleep 格式化time.strftime自定义格式化输出 12lctime = time.localtime()time.strftime(&quot;%Y-%m-%d %A %H:%M:%S&quot;, lctime) sleeptime.sleep() 以秒为单位 random库Python通过random库提供各种伪随机数 随机种子——seed(a=None) 相同的种子会产生相同的随机数 如果不设置随机种子，以系统当前时间为默认值 产生随机整数 randint(a, b) 产生[a,b]之间 randrange(a) 产生[0,a) randrange(a, b, step) 产生[a, b), 以step为步长 产生随机浮点数 random() 产生[0.0,1.0) uniform(a, b) 产生[a, b] 序列用函数 choice(seq) 从seq返回一个 choices(seq, weights=None, k) 对seq进行k次，可设置权重 shuffle(seq) 将seq随机排列 sample(pop, k) 从pop中随机可，以列表返回，k不能超过len(pop) 概率分布guess(mean, std) collecitons库import collecitons nametuplecollecitons.nametuple(typename, field_names, *, rename=False, default=None, module=None) 12345678910Point = collecitons.nametuple(&quot;Point&quot;, [&quot;x&quot;, &quot;y&quot;])p = Point(1, y=2)p # Point(x=1, y=2)# 可以调用属性print(p.x) # 1# 有元组的性质print(p[0]) # 1x, y = pprint(x) # 1 Counterfrom collecitons import Counter 计数统计 Counter.most_common(n) 最常见的n个 Counter.elements() 展开 deque双向队列 append() appendleft() pop() popleft() itertools库排列组合迭代器 product——笛卡尔积 product(‘ABC’, “01”) product(‘ABC’, repeat = 3) permutations——排列 permutations(range(3)) combinations——组合 combinations(‘abcd’, 2) combinations(range(4), 3) combinations_with_replacement——元素可重复组合 拉链 zip——短拉链 zip(‘abc’, ‘012’, ‘xyz’) 长度不一时，执行到最短的对象处就停止 zip_longest——长拉链 zip_longest(‘abc’, ‘012345’, fillvalue=”?”) 长度不一时，执行到最长的对象处就停止，缺省元素用None或指定的字符替代 无穷迭代器 count(start=0, step=1) 计数 cycle(iterable) 循环 repeat(object, times) 重复 chain(iterables) 锁链 enumerate(iterable, start=0)——枚举（内置） 产出有两个元素组成的元组， 结构式(index, item)，其中index从start开始，item从iterable中取 12for i in enumerate(&quot;pyhton&quot;, start = 1): print(i) groupby(iterable, key=None)——分组 创建一个迭代器，按照key指定的方式，返回iterable中连续的键和组，一般来说要预先对数据进行排序，key为None默认把连续重复元素分组","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"算法中的差分思想","slug":"算法中的差分思想","date":"2020-09-21T14:48:59.000Z","updated":"2020-09-21T14:48:59.343Z","comments":true,"path":"2020/09/21/算法中的差分思想/","link":"","permalink":"http://yoursite.com/2020/09/21/%E7%AE%97%E6%B3%95%E4%B8%AD%E7%9A%84%E5%B7%AE%E5%88%86%E6%80%9D%E6%83%B3/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"C++中的const成员函数","slug":"C++中的const成员函数","date":"2020-09-21T14:43:13.000Z","updated":"2020-10-01T11:18:08.673Z","comments":true,"path":"2020/09/21/C++中的const成员函数/","link":"","permalink":"http://yoursite.com/2020/09/21/C++%E4%B8%AD%E7%9A%84const%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/","excerpt":"我们在定义类的成员函数的时候，往往函数块内会返回一个其他的成员，这种方式实际上是隐式地指向调用该函数的对象的成员，即成员函数通过一个名为this的额外的隐式参数来访问调用它的那个对象。 而我们往往会看到成员函数的参数列表后紧跟着一个const关键字，这个const的作用是修改隐式this指针的类型。","text":"我们在定义类的成员函数的时候，往往函数块内会返回一个其他的成员，这种方式实际上是隐式地指向调用该函数的对象的成员，即成员函数通过一个名为this的额外的隐式参数来访问调用它的那个对象。 而我们往往会看到成员函数的参数列表后紧跟着一个const关键字，这个const的作用是修改隐式this指针的类型。 默认情况下来说，this的类型是指向类类型的非常量版本的指针，可以表示为 struct_name *const, 尽管this是隐式的，但它仍需要遵循初始化原则，这就意味值默认情况下this指针是不能绑定到一个常量对象上的，这也就意味着我们不能在一个常量对象上调用普通成员函数。 123456789101112131415161718// 简单定义一个类struct help&#123; int a; int b; help(int aa, int bb) &#123; a = aa; b = bb; &#125; int helper() &#123; return a; &#125;&#125;;int main(int argc, const char * argv[]) &#123; const help temp(12, 23); // 声明一个常量类对象 int c = temp.helper(); // 错误，因为help()是一个普通成员函数，所以this是指向一个非常量对象，而temp又是一个常量对象，所以会报错 cout &lt;&lt; c &lt;&lt; endl;&#125; 所以在这种情况下，我们应该把this声明为 const struct_name *const 这样就可以解决问题，但又因为this是隐式的，所以我们可以将成员函数的声明改为： 1int helper() const &#123;&#125; 这样就可以将this声明为指向常量对象的版本了。而这种使用const的成员函数也叫做常量成员函数(const member function)。","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"C++中的顶层const和底层const","slug":"C++中的顶层const和底层const","date":"2020-09-01T10:40:27.000Z","updated":"2020-09-21T14:52:36.222Z","comments":true,"path":"2020/09/01/C++中的顶层const和底层const/","link":"","permalink":"http://yoursite.com/2020/09/01/C++%E4%B8%AD%E7%9A%84%E9%A1%B6%E5%B1%82const%E5%92%8C%E5%BA%95%E5%B1%82const/","excerpt":"​ const对象一旦创建后其值就不能再改变。而对于指针这种本身是一个对象，它又可以指向另一个对象的情况时，指针本身是不是常量以及指针所指的是不是一个常量就是两个相互独立的问题了，用名词顶层const(top-level const)表示指针本身是个常量，而用底层const(low-level const)表示指针所指的对象是一个常量。","text":"​ const对象一旦创建后其值就不能再改变。而对于指针这种本身是一个对象，它又可以指向另一个对象的情况时，指针本身是不是常量以及指针所指的是不是一个常量就是两个相互独立的问题了，用名词顶层const(top-level const)表示指针本身是个常量，而用底层const(low-level const)表示指针所指的对象是一个常量。 top-level const 的一些演示1234567//初始化两个非常量int i1 = 20; int i2 = 30;//初始化一个顶层const指针，这个操作意味着指针本身的值是一个常量，其本身是不可以改变的，而指针所指的值是一个非常量是可以改变的int *const p = &amp;i1;p = &amp;i2; //错误。指针p本身是一个常量，是不可以改变的*p = i2; //正确。指针所指的值并不是一个常量，是可以改变的 low-level const 的一些演示1234567//初始化两个非常量int i1 = 20;int i2 = 30;//初始化一个底层const指针，这个操作意味着这个指针指向一个常量，不可以通过该指针去改变指针所指的对象，但指针本身是可以更改的const int *p = &amp;i1;*p = i2; //错误。指针p所指的是一个常量，不可以通过指针去修改其指向的对象p = &amp;i2; //正确。指针本身不是常量，可以修改指针本身 ​ 上面的展示应该很清楚地展示了顶层const和底层const的区别所在，当然我们也可以将一个指针声明为既是底层cosnt亦是顶层const，这样我们就不可以通过指针去修改指针所指的对象，也不可以修改指针本身，其声明方式如下。 1234567//初始化两个非常量int i1 = 20;int i2 = 30;//初始化一个既是底层const也是顶层const的指针const int *const p = &amp;i1;*p = i2; //错误。指针p是一个底层const，其所指的对象是一个常量。p = &amp;i2; //错误。指针p是一个顶层const，其本身是一个常量。 所谓的指向常量的指针(pointer to const)只是指针自己以为自己指向的是常量​ 为什么上面的例子都是初始化两个非常量呢？因为其实对于指向常量的指针来说（意思是底层const），只是指针自以为自己指向的是一个常量，所以指针自觉地不去改变所指的对象。但其实指向常量的指针没有规定其所指的对象必须是一个常量。 12345678//初始化两个非常量int i1 = 20;int i2 = 30;//初始化一个底层const指针，即指向常量的指针const int *p = &amp;i1;*p = i2; //错误。指针认为自己指向的是常量，不能通过自己去改变所指的对象i1 = i2; //正确。指向常量的指针没有规定所指的对象是一个常量，所以可以直接修改非常量对象本身std::cout &lt;&lt; *p; //将会打印&quot;30&quot;，而不是&quot;20&quot; 指针和constexpr​ C++11中，允许将变量声明为constexpr类型以便由编译器来验证变量的值是否是一个常量表达式。但必须明确一点，在constexpr声明中如果定义了一个指针，限定符constexpr仅对指针有效，与指针所指的对象无关。意思就是通过constexpr定义的指针是一个顶层const。 1234constexpr int i = 20; //定义一个常量int j = 100; //定义一个非常量constexpr int *p = &amp;i; //错误。p本身是一个常量，但p所指的不是一个常量，所以p不能指向一个常量整数constexpr int *p = &amp;j; //正确。p本身是一个常量指针，指向一个整数","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"指针","slug":"指针","permalink":"http://yoursite.com/tags/%E6%8C%87%E9%92%88/"},{"name":"const","slug":"const","permalink":"http://yoursite.com/tags/const/"}]},{"title":"对KMP算法的一些理解","slug":"对KMP算法的一些理解","date":"2020-08-24T01:14:10.000Z","updated":"2020-08-29T13:07:55.033Z","comments":true,"path":"2020/08/24/对KMP算法的一些理解/","link":"","permalink":"http://yoursite.com/2020/08/24/%E5%AF%B9KMP%E7%AE%97%E6%B3%95%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/","excerpt":"KMP算法是一种字符串匹配算法，可以在O(n+m)时间复杂度内实现两个字符串的匹配。","text":"KMP算法是一种字符串匹配算法，可以在O(n+m)时间复杂度内实现两个字符串的匹配。 关于字符串匹配暴力解决字符串匹配即通过两个串的每个字符逐一比较，python实现如下： 1234def match(S, P): for i in range(len(S) - len(P) + 1): if S[i:i+len(P)] == P: return i 如果 n = len(S), m = len(P)。那么最坏的情况下，暴力解法的时间复杂度能去到O(nm)。 暴力解法并没有利用字符串匹配过程中残留的一部分信息，而KMP算法则是通过“尽可能减少比较的趟数”来做到优化，即看看能否在匹配失败后，跳过一部分不可能成功的字符串比较来使复杂度降低。 简述KMP起始思路","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/tags/algorithm/"}]},{"title":"vimKeyboard","slug":"vimKeyboard","date":"2020-08-23T13:19:30.000Z","updated":"2020-08-23T13:19:30.000Z","comments":true,"path":"2020/08/23/vimKeyboard/","link":"","permalink":"http://yoursite.com/2020/08/23/vimKeyboard/","excerpt":"","text":"vim键位图","categories":[],"tags":[{"name":"vim","slug":"vim","permalink":"http://yoursite.com/tags/vim/"}]}],"categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"虚函数","slug":"虚函数","permalink":"http://yoursite.com/tags/%E8%99%9A%E5%87%BD%E6%95%B0/"},{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"},{"name":"指针","slug":"指针","permalink":"http://yoursite.com/tags/%E6%8C%87%E9%92%88/"},{"name":"const","slug":"const","permalink":"http://yoursite.com/tags/const/"},{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/tags/algorithm/"},{"name":"vim","slug":"vim","permalink":"http://yoursite.com/tags/vim/"}]}