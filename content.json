{"meta":{"title":"MoChen's","subtitle":"","description":"临渊羡鱼，不如退而结网","author":"MoChen","url":"http://yoursite.com","root":"/"},"pages":[{"title":"tags","date":"2020-08-23T14:01:22.000Z","updated":"2020-08-23T14:09:32.600Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Linux下的I/O多路复用（I/O多路转接） ","slug":"Linux下的I:O多路复用（I:O多路转接）","date":"2021-04-18T22:57:41.000Z","updated":"2021-04-18T23:00:27.770Z","comments":true,"path":"2021/04/18/Linux下的I:O多路复用（I:O多路转接）/","link":"","permalink":"http://yoursite.com/2021/04/18/Linux%E4%B8%8B%E7%9A%84I:O%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%EF%BC%88I:O%E5%A4%9A%E8%B7%AF%E8%BD%AC%E6%8E%A5%EF%BC%89/","excerpt":"I/O 多路复用使得程序能同时监听多个文件描述符，能够提高程序的性能，Linux 下实现 I/O 多路用的系统调用主要有 select、poll 和 epoll。","text":"I/O 多路复用使得程序能同时监听多个文件描述符，能够提高程序的性能，Linux 下实现 I/O 多路用的系统调用主要有 select、poll 和 epoll。 select 主旨思想： 首先要构造一个关于文件描述符的列表，将要监听的文件描述符添加到该列表中。 调用一个系统函数，监听该列表中的文件描述符，直到这些描述符中的一个或者多个进行I/O操作时，该函数才返回。 a. 这个函数阻塞的 b. 函数对文件描述符的检测的操作是由内核完成的 在返回时，它会告诉进程有多少（哪些）描述符要进行I/O操作。 1234567891011121314151617181920212223242526272829303132333435363738&#x2F;&#x2F; sizeof(fd_set) &#x3D; 128 1024 #include &lt;sys&#x2F;time.h&gt; #include &lt;sys&#x2F;types.h&gt; #include &lt;unistd.h&gt; #include &lt;sys&#x2F;select.h&gt; int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout); - 参数： - nfds : 委托内核检测的最大文件描述符的值 + 1 - readfds : 要检测的文件描述符的读的集合，委托内核检测哪些文件描述符的读的属性 - 一般检测读操作 - 对应的是对方发送过来的数据，因为读是被动的接收数据，检测的就是读缓冲区 - 是一个传入传出参数 - writefds : 要检测的文件描述符的写的集合，委托内核检测哪些文件描述符的写的属性 - 委托内核检测写缓冲区是不是还可以写数据（不满的就可以写） - exceptfds : 检测发生异常的文件描述符的集合 - timeout : 设置的超时时间 struct timeval &#123; long tv_sec; &#x2F;* seconds *&#x2F; long tv_usec; &#x2F;* microseconds *&#x2F; &#125;; - NULL : 永久阻塞，直到检测到了文件描述符有变化 - tv_sec &#x3D; 0 tv_usec &#x3D; 0， 不阻塞 - tv_sec &gt; 0 tv_usec &gt; 0， 阻塞对应的时间 - 返回值 : - -1 : 失败 - &gt;0(n) : 检测的集合中有n个文件描述符发生了变化 &#x2F;&#x2F; 将参数文件描述符fd对应的标志位设置为0 void FD_CLR(int fd, fd_set *set); &#x2F;&#x2F; 判断fd对应的标志位是0还是1， 返回值 ： fd对应的标志位的值，0，返回0， 1，返回1 int FD_ISSET(int fd, fd_set *set); &#x2F;&#x2F; 将参数文件描述符fd 对应的标志位，设置为1 void FD_SET(int fd, fd_set *set);&#x2F;&#x2F; fd_set一共有1024 bit, 全部初始化为0 void FD_ZERO(fd_set *set); poll1234567891011121314151617181920212223#include &lt;poll.h&gt; struct pollfd &#123; int fd; &#x2F;* 委托内核检测的文件描述符 *&#x2F; short events; &#x2F;* 委托内核检测文件描述符的什么事件 *&#x2F; short revents; &#x2F;* 文件描述符实际发生的事件 *&#x2F; &#125;;struct pollfd myfd; myfd.fd &#x3D; 5; myfd.events &#x3D; POLLIN | POLLOUT; int poll(struct pollfd *fds, nfds_t nfds, int timeout); - 参数： - fds : 是一个struct pollfd 结构体数组，这是一个需要检测的文件描述符的集合 - nfds : 这个是第一个参数数组中最后一个有效元素的下标 + 1 - timeout : 阻塞时长 0 : 不阻塞 -1 : 阻塞，当检测到需要检测的文件描述符有变化，解除阻塞 &gt;0 : 阻塞的时长 - - 返回值： -1 : 失败 &gt;0（n） : 成功,n表示检测到集合中有n个文件描述符发生变化 epoll12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;sys&#x2F;epoll.h&gt; &#x2F;&#x2F; 创建一个新的epoll实例。在内核中创建了一个数据，这个数据中有两个比较重要的数据，&#x2F;&#x2F;一个是需要检 测的文件描述符的信息（红黑树），还有一个是就绪列表，存放检测到数据发送&#x2F;&#x2F;改变的文件描述符信息（双向 链表）。 int epoll_create(int size); - 参数： size : 目前没有意义了。随便写一个数，必须大于0 - 返回值： -1 : 失败 &gt; 0 : 文件描述符，操作epoll实例的typedef union epoll_data &#123; void *ptr; int fd; uint32_t u32; uint64_t u64; &#125; epoll_data_t; struct epoll_event &#123; uint32_t events; &#x2F;* Epoll events *&#x2F; epoll_data_t data; &#x2F;* User data variable *&#x2F; &#125;;常见的Epoll检测事件： - EPOLLIN - EPOLLOUT - EPOLLERR &#x2F;&#x2F; 对epoll实例进行管理：添加文件描述符信息，删除信息，修改信息 int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); - 参数： - epfd : epoll实例对应的文件描述符 - op : 要进行什么操作 EPOLL_CTL_ADD: 添加 EPOLL_CTL_MOD: 修改 EPOLL_CTL_DEL: 删除 - fd : 要检测的文件描述符 - event : 检测文件描述符什么事情 &#x2F;&#x2F; 检测函数 int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout); - 参数： - epfd : epoll实例对应的文件描述符 - events : 传出参数，保存了发送了变化的文件描述符的信息 - maxevents : 第二个参数结构体数组的大小 - timeout : 阻塞时间 - 0 : 不阻塞 - -1 : 阻塞，直到检测到fd数据发生变化，解除阻塞 - &gt; 0 : 阻塞的时长（毫秒） - 返回值： - 成功，返回发送变化的文件描述符的个数 &gt; 0 - 失败 -1 epoll的工作模式： LT 模式 （水平触发） 假设委托内核检测读事件 -&gt; 检测fd的读缓冲区 读缓冲区有数据 - &gt; epoll检测到了会给用户通知 a. 用户不读数据，数据一直在缓冲区，epoll 会一直通知 b. 用户只读了一部分数据，epoll会通知 c. 缓冲区的数据读完了，不通知 LT（level - triggered）是缺省的工作方式，并且同时支持 block 和 no-block socket。在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的 fd 进行 IO 操作。如果你不作任何操作，内核还是会继续通知你的。 ET 模式（边沿触发） 假设委托内核检测读事件 -&gt; 检测fd的读缓冲区 读缓冲区有数据 - &gt; epoll检测到了会给用户通知 a. 用户不读数据，数据一致在缓冲区中，epoll下次检测的时候就不通知了 b. 用户只读了一部分数据，epoll不通知 c. 缓冲区的数据读完了，不通知 ET（edge - triggered）是高速工作方式，只支持 no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了。但是请注意，如果一直不对这个 fd 作 IO 操作（从而导致它再次变成未就绪），内核不会发送更多的通知（only once）。 ET 模式在很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。epoll工作在 ET 模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。 12345678910struct epoll_event &#123; uint32_t events; &#x2F;* Epoll events *&#x2F; epoll_data_t data; &#x2F;* User data variable *&#x2F; &#125;;常见的Epoll检测事件： - EPOLLIN - EPOLLOUT - EPOLLERR - EPOLLET","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"},{"name":"select","slug":"select","permalink":"http://yoursite.com/tags/select/"},{"name":"poll","slug":"poll","permalink":"http://yoursite.com/tags/poll/"},{"name":"epoll","slug":"epoll","permalink":"http://yoursite.com/tags/epoll/"}]},{"title":"Linux多线程开发笔记","slug":"Linux多线程开发笔记","date":"2021-04-17T21:13:19.000Z","updated":"2021-04-17T21:18:27.864Z","comments":true,"path":"2021/04/17/Linux多线程开发笔记/","link":"","permalink":"http://yoursite.com/2021/04/17/Linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/","excerpt":"线程线程概述 与进程（process）类似，线程（thread）是允许应用程序并发执行多个任务的一种机制。一个进程可以包含多个线程。同一个程序中的所有线程均会独立执行相同程序，且共享同一份全局内存区域，其中包括初始化数据段、未初始化数据段，以及堆内存段。（传统意义上的 UNIX 进程只是多线程程序的一个特例，该进程只包含一个线程）","text":"线程线程概述 与进程（process）类似，线程（thread）是允许应用程序并发执行多个任务的一种机制。一个进程可以包含多个线程。同一个程序中的所有线程均会独立执行相同程序，且共享同一份全局内存区域，其中包括初始化数据段、未初始化数据段，以及堆内存段。（传统意义上的 UNIX 进程只是多线程程序的一个特例，该进程只包含一个线程） 进程是 CPU 分配资源的最小单位，线程是操作系统调度执行的最小单位。 线程是轻量级的进程（LWP：Light Weight Process），在 Linux 环境下线程的本质仍是进程。 查看指定进程的 LWP 号：ps –Lf pid 线程和进程区别 进程间的信息难以共享。由于除去只读代码段外，父子进程并未共享内存，因此必须采用一些进程间通信方式，在进程间进行信息交换。 调用 fork() 来创建进程的代价相对较高，即便利用写时复制技术，仍然需要复制诸如内存页表和文件描述符表之类的多种进程属性，这意味着 fork() 调用在时间上的开销依然不菲。 线程之间能够方便、快速地共享信息。只需将数据复制到共享（全局或堆）变量中即可。 创建线程比创建进程通常要快 10 倍甚至更多。线程间是共享虚拟地址空间的，无需采用写时复制来复制内存，也无需复制页表。 线程之间共享和非共享资源 共享资源 进程ID和父进程ID 进程组ID和会话ID 用户ID和用户组ID 文件描述符表 信号处置 文件系统的相关信息：文件权限掩码（umask）、当前工作目录 虚拟地址空间（除栈、.text） 非共享资源 线程ID 信号掩码 线程特有数据 error变量 实时调度策略和优先级 栈、本地变量和函数的调用链接信息 NPTL 当 Linux 最初开发时，在内核中并不能真正支持线程。但是它的确可以通过 clone()系统调用将进程作为可调度的实体。这个调用创建了调用进程（calling process）的一个拷贝，这个拷贝与调用进程共享相同的地址空间。LinuxThreads 项目使用这个调用来完成在用户空间模拟对线程的支持。不幸的是，这种方法有一些缺点，尤其是在信号处理、调度和进程间同步等方面都存在问题。另外，这个线程模型也不符合 POSIX 的要求。 要改进 LinuxThreads，需要内核的支持，并且重写线程库。有两个相互竞争的项目开始来满足这些要求。一个包括 IBM 的开发人员的团队开展了 NGPT（Next-GenerationPOSIX Threads）项目。同时，Red Hat 的一些开发人员开展了 NPTL 项目。NGPT在 2003 年中期被放弃了，把这个领域完全留给了 NPTL。 NPTL，或称为 Native POSIX Thread Library，是 Linux 线程的一个新实现，它克服了 LinuxThreads 的缺点，同时也符合 POSIX 的需求。与 LinuxThreads 相比，它在性能和稳定性方面都提供了重大的改进。 查看当前 pthread 库版本：getconf GNU_LIBPTHREAD_VERSION 线程操作 创建线程 12345678910111213141516171819一般情况下,main函数所在的线程我们称之为主线程（main线程），其余创建的线程称之为子线程。程序中默认只有一个进程，fork()函数调用，2进行程序中默认只有一个线程，pthread_create()函数调用，2个线程。#include &lt;pthread.h&gt;int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg); - 功能：创建一个子线程 - 参数： - thread：传出参数，线程创建成功后，子线程的线程ID被写到该变量中。 - attr : 设置线程的属性，一般使用默认值，NULL - start_routine : 函数指针，这个函数是子线程需要处理的逻辑代码 - arg : 给第三个参数使用，传参 - 返回值： 成功：0 失败：返回错误号。这个错误号和之前errno不太一样。 获取错误号的信息： char * strerror(int errnum); 终止线程 12345678910111213#include &lt;pthread.h&gt;void pthread_exit(void *retval); 功能：终止一个线程，在哪个线程中调用，就表示终止哪个线程 参数： retval:需要传递一个指针，作为一个返回值，可以在pthread_join()中获取到。pthread_t pthread_self(void); 功能：获取当前的线程的线程IDint pthread_equal(pthread_t t1, pthread_t t2); 功能：比较两个线程ID是否相等 不同的操作系统，pthread_t类型的实现不一样，有的是无符号的长整型，有的 是使用结构体去实现的。 连接一个已终止的线程 123456789101112#include &lt;pthread.h&gt;int pthread_join(pthread_t thread, void **retval); - 功能：和一个已经终止的线程进行连接 回收子线程的资源 这个函数是阻塞函数，调用一次只能回收一个子线程 一般在主线程中使用 - 参数： - thread：需要回收的子线程的ID - retval: 接收子线程退出时的返回值 - 返回值： 0 : 成功 非0 : 失败，返回的错误号 线程分离 123456789#include &lt;pthread.h&gt;int pthread_detach(pthread_t thread); - 功能：分离一个线程。被分离的线程在终止的时候，会自动释放资源返回给系统。 1.不能多次分离，会产生不可预料的行为。 2.不能去连接一个已经分离的线程，会报错。 - 参数：需要分离的线程的ID - 返回值： 成功：0 失败：返回错误号 线程取消 1234567#include &lt;pthread.h&gt;int pthread_cancel(pthread_t thread); - 功能：取消线程（让线程终止） 取消某个线程，可以终止某个线程的运行， 但是并不是立马终止，而是当子线程执行到一个取消点，线程才会终止。 取消点：系统规定好的一些系统调用，我们可以粗略的理解为从用户区到内核区的切换， 这个位置称之为取消点。 线程属性 1234567891011int pthread_attr_init(pthread_attr_t *attr); - 初始化线程属性变量 int pthread_attr_destroy(pthread_attr_t *attr); - 释放线程属性的资源 int pthread_attr_getdetachstate(const pthread_attr_t *attr, int *detachstate); - 获取线程分离的状态属性 int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate); - 设置线程分离的状态属性 线程同步线程同步 线程的主要优势在于，能够通过全局变量来共享信息。不过，这种便捷的共享是有代价的：必须确保多个线程不会同时修改同一变量，或者某一线程不会读取正在由其他线程修改的变量。 临界区是指访问某一共享资源的代码片段，并且这段代码的执行应为原子操作，也就是同时访问同一共享资源的其他线程不应终端该片段的执行。 线程同步：即当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，直到该线程完成操作，其他线程才能对该内存地址进行操作，而其他线程则处于等待状态。 互斥量 为避免线程更新共享变量时出现问题，可以使用互斥量（mutex 是 mutual exclusion的缩写）来确保同时仅有一个线程可以访问某项共享资源。可以使用互斥量来保证对任意共享资源的原子访问。 互斥量有两种状态：已锁定（locked）和未锁定（unlocked）。任何时候，至多只有一个线程可以锁定该互斥量。试图对已经锁定的某一互斥量再次加锁，将可能阻塞线程或者报错失败，具体取决于加锁时使用的方法。 一旦线程锁定互斥量，随即成为该互斥量的所有者，只有所有者才能给互斥量解锁。一般情况下，对每一共享资源（可能由多个相关变量组成）会使用不同的互斥量，每一线程在访问 同一资源时将采用如下协议： 针对共享资源锁定互斥量 访问共享资源 对互斥量解锁 互斥量相关操作函数： 123456789101112131415161718192021互斥量的类型 pthread_mutex_tint pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr); - 初始化互斥量 - 参数 ： - mutex ： 需要初始化的互斥量变量 - attr ： 互斥量相关的属性，NULL - restrict : C语言的修饰符，被修饰的指针，不能由另外的一个指针进行操作。 pthread_mutex_t *restrict mutex &#x3D; xxx; pthread_mutex_t * mutex1 &#x3D; mutex;int pthread_mutex_destroy(pthread_mutex_t *mutex); - 释放互斥量的资源int pthread_mutex_lock(pthread_mutex_t *mutex); - 加锁，阻塞的，如果有一个线程加锁了，那么其他的线程只能阻塞等待int pthread_mutex_trylock(pthread_mutex_t *mutex); - 尝试加锁，如果加锁失败，不会阻塞，会直接返回。int pthread_mutex_unlock(pthread_mutex_t *mutex); - 解锁 死锁 有时，一个线程需要同时访问两个或更多不同的共享资源，而每个资源又都由不同的互斥量管理。当超过一个线程加锁同一组互斥量时，就有可能发生死锁。 两个或两个以上的进程在执行过程中，因争夺共享资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁。 死锁的几种场景： 忘记释放锁 重复加锁 多线程多锁，抢占锁资源 读写锁 当有一个线程已经持有互斥锁时，互斥锁将所有试图进入临界区的线程都阻塞住。但是考虑一种情形，当前持有互斥锁的线程只是要读访问共享资源，而同时有其它几个线程也想读取这个共享资源，但是由于互斥锁的排它性，所有其它线程都无法获取锁，也就无法读访问共享资源了，但是实际上多个线程同时读访问共享资源并不会导致问题。 在对数据的读写操作中，更多的是读操作，写操作较少，例如对数据库数据的读写应用。为了满足当前能够允许多个读出，但只允许一个写入的需求，线程提供了读写锁来实现。 读写锁的特点： 如果有其它线程读数据，则允许其它线程执行读操作，但不允许写操作。 如果有其它线程写数据，则其它线程都不允许读、写操作。 写是独占的，写的优先级高。 读写锁相关操作函数123456789读写锁的类型 pthread_rwlock_tint pthread_rwlock_init(pthread_rwlock_t *restrict rwlock, const pthread_rwlockattr_t *restrict attr);int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);int pthread_rwlock_unlock(pthread_rwlock_t *rwlock); 生产者和消费者模型略 条件变量某个条件满足了解除阻塞。 条件变量不是锁，配合互斥量使用实现线程同步。 1234567891011条件变量的类型 pthread_cond_tint pthread_cond_init(pthread_cond_t *restrict cond, const pthread_condattr_t *restrict attr);int pthread_cond_destroy(pthread_cond_t *cond);int pthread_cond_wait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex); - 等待，调用了该函数，线程会阻塞。并对mutex解锁。int pthread_cond_timedwait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex, const struct timespec *restrict abstime); - 等待多长时间，调用了这个函数，线程会阻塞，直到指定的时间结束。int pthread_cond_signal(pthread_cond_t *cond); - 唤醒一个或者多个等待的线程int pthread_cond_broadcast(pthread_cond_t *cond); - 唤醒所有的等待的线程 信号量123456789101112131415161718192021222324252627282930313233343536信号量的类型 sem_tint sem_init(sem_t *sem, int pshared, unsigned int value); - 初始化信号量 - 参数： - sem : 信号量变量的地址 - pshared : 0 用在线程间 ，非0 用在进程间 - value : 信号量中的值int sem_destroy(sem_t *sem); - 释放资源int sem_wait(sem_t *sem); - 对信号量加锁，调用一次对信号量的值-1，如果值为0，就阻塞int sem_trywait(sem_t *sem);int sem_timedwait(sem_t *sem, const struct timespec *abs_timeout);int sem_post(sem_t *sem); - 对信号量解锁，调用一次对信号量的值+1int sem_getvalue(sem_t *sem, int *sval);sem_t psem;sem_t csem;init(psem, 0, 8);init(csem, 0, 0);producer() &#123; sem_wait(&amp;psem); sem_post(&amp;csem)&#125;customer() &#123; sem_wait(&amp;csem); sem_post(&amp;psem)&#125;","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"},{"name":"多线程","slug":"多线程","permalink":"http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"Linux多进程开发笔记","slug":"Linux多进程开发笔记","date":"2021-04-17T19:33:42.000Z","updated":"2021-04-17T19:36:12.128Z","comments":true,"path":"2021/04/17/Linux多进程开发笔记/","link":"","permalink":"http://yoursite.com/2021/04/17/Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/","excerpt":"进程概述程序是包含一系列信息的文件，这些信息描述了如何在运行时创建一个进程： 二进制格式标识：每个程序文件都包含用于描述可执行文件格式的元信息。内核利用此信息来解释文件中的其他信息。（ELF可执行连接格式） 机器语言指令：对程序算法进行编码。 程序入口地址：标识程序开始执行时的起始指令位置。","text":"进程概述程序是包含一系列信息的文件，这些信息描述了如何在运行时创建一个进程： 二进制格式标识：每个程序文件都包含用于描述可执行文件格式的元信息。内核利用此信息来解释文件中的其他信息。（ELF可执行连接格式） 机器语言指令：对程序算法进行编码。 程序入口地址：标识程序开始执行时的起始指令位置。 数据：程序文件包含的变量初始值和程序使用的字面量值（比如字符串）。 符号表及重定位表：描述程序中函数和变量的位置及名称。这些表格有多重用途，其中包括调试和运行时的符号解析（动态链接）。 共享库和动态链接信息：程序文件所包含的一些字段，列出了程序运行时需要使用的共享库，以及加载共享库的动态连接器的路径名。 其他信息：程序文件还包含许多其他信息，用以描述如何创建进程。 进程是正在运行的程序的实例。是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元。 可以用一个程序来创建多个进程，进程是由内核定义的抽象实体，并为该实体分配用以执行程序的各项系统资源。从内核的角度看，进程由用户内存空间和一系列内核数据结构组成，其中用户内存空间包含了程序代码及代码所使用的变量，而内核数据结构则用于维护进程状态信息。记录在内核数据结构中的信息包括许多与进程相关的标识号（IDs）、虚拟内存表、打开文件的描述符表、信号传递及处理的有关信息、进程资源使用及限制、当前工作目录和大量的其他信息。 对于一个单 CPU 系统来说，程序同时处于运行状态只是一种宏观上的概念，他们虽然都已经开始运行，但就微观而言，任意时刻，CPU 上运行的程序只有一个。 时间片 时间片（timeslice）又称为“量子（quantum）”或“处理器片（processor slice）”是操作系统分配给每个正在运行的进程微观上的一段 CPU 时间。事实上，虽然一台计算机通常可能有多个 CPU，但是同一个 CPU 永远不可能真正地同时运行多个任务。在只考虑一个 CPU 的情况下，这些进程“看起来像”同时运行的，实则是轮番穿插地运行，由于时间片通常很短（在 Linux 上为 5ms－800ms），用户不会感觉到。 时间片由操作系统内核的调度程序分配给每个进程。首先，内核会给每个进程分配相等的初始时间片，然后每个进程轮番地执行相应的时间，当所有进程都处于时间片耗尽的状态时，内核会重新为每个进程计算并分配时间片，如此往复。 并行（parallel）：指在同一时刻，有多条指令在多个处理器上同时执行。 并发（concurrency）：指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行。 进程控制块（PCB） 为了管理进程，内核必须对每个进程所做的事情进行清楚的描述。内核为每个进程分配一个 PCB(Processing Control Block)进程控制块，维护进程相关的信息，Linux 内核的进程控制块是 task_struct 结构体。 在 /usr/src/linux-headers-xxx/include/linux/sched.h 文件中可以查看 struct task_struct 结构体定义。其内部成员有很多，我们只需要掌握以下部分即可： 进程id：系统中每个进程有唯一的 id，用 pid_t 类型表示，其实就是一个非负整数 进程的状态：有就绪、运行、挂起、停止等状态 进程切换时需要保存和恢复的一些CPU寄存器 描述虚拟地址空间的信息 描述控制终端的信息 进程状态转换进程状态反映进程执行过程的变化。这些状态随着进程的执行和外界条件的变化而转换。 在三态模型中，进程状态分为三个基本状态，即就绪态，运行态，阻塞态。在五态模型 中，进程分为新建态、就绪态，运行态，阻塞态，终止态。 运行态：进程占有处理器正在运行 就绪态：进程具备运行条件，等待系统分配处理器以便运行。当进程已分配到除CPU以外的所有必要资源后，只要再获得CPU，便可立即执行。在一个系统中处于就绪状态的进程可能有多个，通常将它们排成一个队列，称为就绪队列 阻塞态：又称为等待(wait)态或睡眠(sleep)态，指进程不具备运行条件，正在等待某个事件的完成 新建态：进程刚被创建时的状态，尚未进入就绪队列 终止态：进程完成任务到达正常结束点，或出现无法克服的错误而异常终止，或被操作系统及有终止权的进程所终止时所处的状态。进入终止态的进程以后不再执行，但依然保留在操作系统中等待善后。一旦其他进程完成了对终止态进程的信息抽取之后，操作系统将删除该进程。 进程相关命令 查看进程 ps aux/ajx a：显示终端上的所有进程，包括其他用户的进程 u：显示进程的详细信息 x：显示没有控制终端的进程 j：列出与作业控制相关的信息 STAT参数意义： D 不可中断 Uninterruptible（usually IO） R 正在运行，或在队列中的进程 S(大写) 处于休眠状态 T 停止或被追踪 Z 僵尸进程 W 进入内存交换（从内核2.6开始无效） X 死掉的进程 &lt; 高优先级 N 低优先级 s 包含子进程 位于前台的进程组 实时显示进程动态 top 可以在使用 top 命令时加上 -d 来指定显示信息更新的时间间隔，在 top 命令执行后，可以按以下按键对显示的结果进行排序： M 根据内存使用量排序 P 根据 CPU 占有率排序 T 根据进程运行时间长短排序 U 根据用户名来筛选进程 K 输入指定的 PID 杀死进程 杀死进程 kill [-signal] pid kill –l 列出所有信号 kill –SIGKILL 进程ID kill -9 进程ID killall name 根据进程名杀死进程 进程号和相关函数 每个进程都由进程号来标识，其类型为 pid_t（整型），进程号的范围：0～32767。进程号总是唯一的，但可以重用。当一个进程终止后，其进程号就可以再次使用。 任何进程（除 init 进程）都是由另一个进程创建，该进程称为被创建进程的父进程，对应的进程号称为父进程号（PPID）。 进程组是一个或多个进程的集合。他们之间相互关联，进程组可以接收同一终端的各种信号，关联的进程有一个进程组号（PGID）。默认情况下，当前的进程号会当做当前的进程组号。 进程号和进程组相关函数： pid_t getpid(void); // 当前进程id pid_t getppid(void); // 父进程id pid_t getpgid(pid_t pid); // 组进程id 进程创建系统允许一个进程创建新进程，新进程即为子进程，子进程还可以创建新的子进程，形成进程树结构模型。 123456789101112131415161718192021222324252627282930#include &lt;sys&#x2F;types.h&gt;#include &lt;unistd.h&gt;pid_t fork(void); 函数的作用：用于创建子进程。 返回值： fork()的返回值会返回两次。一次是在父进程中，一次是在子进程中。 在父进程中返回创建的子进程的ID, 在子进程中返回0 如何区分父进程和子进程：通过fork的返回值。 在父进程中返回-1，表示创建子进程失败，并且设置errno 父子进程之间的关系： 区别： 1.fork()函数的返回值不同 父进程中: &gt;0 返回的子进程的ID 子进程中: &#x3D;0 2.pcb中的一些数据 当前的进程的id pid 当前的进程的父进程的id ppid 信号集 共同点： 某些状态下：子进程刚被创建出来，还没有执行任何的写数据的操作 - 用户区的数据 - 文件描述符表 父子进程对变量是不是共享的？ - 刚开始的时候，是一样的，共享的。如果修改了数据，不共享了。 - 读时共享（子进程被创建，两个进程没有做任何的写的操作），写时拷贝。 使用 GDB 调试的时候，GDB 默认只能跟踪一个进程，可以在 fork 函数调用之前，通过指令设置 GDB 调试工具跟踪父进程或者是跟踪子进程，默认跟踪父进程。 设置调试父进程或者子进程：set follow-fork-mode [parent（默认）| child] 设置调试模式：set detach-on-fork [on | off] 默认为 on，表示调试当前进程的时候，其它的进程继续运行，如果为 off，调试当前进程的时候，其它进程被 GDB 挂起。 查看调试的进程：info inferiors 切换当前调试的进程：inferior id 使进程脱离 GDB 调试：detach inferiors id exec函数族exec 函数族的作用是根据指定的文件名找到可执行文件，并用它来取代调用进程的内容，换句话说，就是在调用进程内部执行一个可执行文件。 exec 函数族的函数执行成功后不会返回，因为调用进程的实体，包括代码段，数据段和堆栈等都已经被新的内容取代，只留下进程 ID 等一些表面上的信息仍保持原样，颇有些神似“三十六计”中的“金蝉脱壳”。看上去还是旧的躯壳，却已经注入了新的灵魂。只有调用失败了，它们才会返回 -1，从原程序的调用点接着往下执行。 exec函数族 int execl(const char *path, const char arg, …/ (char *) NULL */); int execlp(const char *file, const char arg, … / (char *) NULL */); int execle(const char *path, const char arg, …/, (char *) NULL, char *const envp[] */); int execv(const char *path, char *const argv[]); int execvp(const char *file, char *const argv[]); int execvpe(const char *file, char *const argv[], char *const envp[]); int execve(const char *filename, char *const argv[], char *const envp[]); l(list) 参数地址列表，以空指针结尾 v(vector) 存有各参数地址的指针数组的地址 p(path) 按 PATH 环境变量指定的目录搜索可执行文件 e(environment) 存有环境变量字符串地址的指针数组的地址 execl123456789101112131415#include &lt;unistd.h&gt;int execl(const char *path, const char *arg, ...); - 参数： - path:需要指定的执行的文件的路径或者名称 a.out &#x2F;home&#x2F;nowcoder&#x2F;a.out 推荐使用绝对路径 .&#x2F;a.out hello world - arg:是执行可执行文件所需要的参数列表 第一个参数一般没有什么作用，为了方便，一般写的是执行的程序的名称 从第二个参数开始往后，就是程序执行所需要的的参数列表。 参数最后需要以NULL结束（哨兵） - 返回值： 只有当调用失败，才会有返回值，返回-1，并且设置errno 如果调用成功，没有返回值。 execlp123456789101112131415161718192021222324#include &lt;unistd.h&gt;int execlp(const char *file, const char *arg, ... ); - 会到环境变量中查找指定的可执行文件，如果找到了就执行，找不到就执行不成功。 - 参数： - file:需要执行的可执行文件的文件名 a.out ps - arg:是执行可执行文件所需要的参数列表 第一个参数一般没有什么作用，为了方便，一般写的是执行的程序的名称 从第二个参数开始往后，就是程序执行所需要的的参数列表。 参数最后需要以NULL结束（哨兵） - 返回值： 只有当调用失败，才会有返回值，返回-1，并且设置errno 如果调用成功，没有返回值。int execv(const char *path, char *const argv[]);argv是需要的参数的一个字符串数组char * argv[] &#x3D; &#123;&quot;ps&quot;, &quot;aux&quot;, NULL&#125;;execv(&quot;&#x2F;bin&#x2F;ps&quot;, argv);int execve(const char *filename, char *const argv[], char *const envp[]);char * envp[] &#x3D; &#123;&quot;&#x2F;home&#x2F;nowcoder&quot;, &quot;&#x2F;home&#x2F;bbb&quot;, &quot;&#x2F;home&#x2F;aaa&quot;&#125;; 进程退出、孤儿进程、僵尸进程进程退出1234567#include &lt;stdlib.h&gt; &#x2F;&#x2F; C程序函数void exit(int status);#include &lt;unistd.h&gt; &#x2F;&#x2F;系统调用void _exit(int status);status参数：是进程退出时的一个状态信息。父进程回收子进程资源的时候可以获取到。 孤儿进程 父进程运行结束，但子进程还在运行（未运行结束），这样的子进程就称为孤儿进程（Orphan Process）。 每当出现一个孤儿进程的时候，内核就把孤儿进程的父进程设置为 init ，而 init进程会循环地 wait() 它的已经退出的子进程。这样，当一个孤儿进程凄凉地结束了其生命周期的时候，init 进程就会代表党和政府出面处理它的一切善后工作。 因此孤儿进程并不会有什么危害。 僵尸进程 每个进程结束之后, 都会释放自己地址空间中的用户区数据，内核区的 PCB 没有办法自己释放掉，需要父进程去释放。 进程终止时，父进程尚未回收，子进程残留资源（PCB）存放于内核中，变成僵尸（Zombie）进程。 僵尸进程不能被 kill -9 杀死，这样就会导致一个问题，如果父进程不调用 wait()或 waitpid() 的话，那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程，此即为僵尸进程的危害，应当避免。 进程回收 在每个进程退出的时候，内核释放该进程所有的资源、包括打开的文件、占用的内存等。但是仍然为其保留一定的信息，这些信息主要主要指进程控制块PCB的信息（包括进程号、退出状态、运行时间等）。 父进程可以通过调用wait或waitpid得到它的退出状态同时彻底清除掉这个进程。 wait() 和 waitpid() 函数的功能一样，区别在于，wait() 函数会阻塞，waitpid() 可以设置不阻塞，waitpid() 还可以指定等待哪个子进程结束。 注意：一次wait或waitpid调用只能清理一个子进程，清理多个子进程应使用循环。 退出信息相关宏函数 WIFEXITED(status) 非0，进程正常退出 WEXITSTATUS(status) 如果上宏为真，获取进程退出的状态（exit的参数） WIFSIGNALED(status) 非0，进程异常终止 WTERMSIG(status) 如果上宏为真，获取使进程终止的信号编号 WIFSTOPPED(status) 非0，进程处于暂停状态 WSTOPSIG(status) 如果上宏为真，获取使进程暂停的信号的编号 WIFCONTINUED(status) 非0，进程暂停后已经继续运行 wait和waitpid函数wait函数123456789101112#include &lt;sys&#x2F;types.h&gt;#include &lt;sys&#x2F;wait.h&gt;pid_t wait(int *wstatus); 功能：等待任意一个子进程结束，如果任意一个子进程结束了，次函数会回收子进程的资源。 参数：int *wstatus 进程退出时的状态信息，传入的是一个int类型的地址，传出参数。 返回值： - 成功：返回被回收的子进程的id - 失败：-1 (所有的子进程都结束，调用函数失败)调用wait函数的进程会被挂起（阻塞），直到它的一个子进程退出或者收到一个不能被忽略的信号时才被唤醒（相当于继续往下执行）如果没有子进程了，函数立刻返回，返回-1；如果子进程都已经结束了，也会立即返回，返回-1. waitpid函数1234567891011121314151617#include &lt;sys&#x2F;types.h&gt;#include &lt;sys&#x2F;wait.h&gt;pid_t waitpid(pid_t pid, int *wstatus, int options); 功能：回收指定进程号的子进程，可以设置是否阻塞。 参数： - pid: pid &gt; 0 : 某个子进程的pid pid &#x3D; 0 : 回收当前进程组的所有子进程 pid &#x3D; -1 : 回收所有的子进程，相当于 wait() （最常用） pid &lt; -1 : 某个进程组的组id的绝对值，回收指定进程组中的子进程 - options：设置阻塞或者非阻塞 0 : 阻塞 WNOHANG : 非阻塞 - 返回值： &gt; 0 : 返回子进程的id &#x3D; 0 : options&#x3D;WNOHANG, 表示还有子进程或者 &#x3D; -1 ：错误，或者没有子进程了 进程间通信进程间通讯概念 进程是一个独立的资源分配单元，不同进程（这里所说的进程通常指的是用户进程）之间 的资源是独立的，没有关联，不能在一个进程中直接访问另一个进程的资源。 但是，进程不是孤立的，不同的进程需要进行信息的交互和状态的传递等，因此需要进程 间通信( IPC：Inter Processes Communication )。 进程间通信的目的： 数据传输：一个进程需要将它的数据发送给另一个进程。 通知事件：一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如进程终止时要通知父进程）。 资源共享：多个进程之间共享同样的资源。为了做到这一点，需要内核提供互斥和同步机制。 进程控制：有些进程希望完全控制另一个进程的执行（如 Debug 进程），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。 Linux进程间通信的方式同一主机进程间通信： Unix进程间通信方式： 匿名管道 有名管道 信号 System V进程间通信方式 &amp; POSIX进程间通信方式： 消息队列 共享内存 信号量 不同主机（网络）进程间通信： Socket 匿名管道 管道也叫无名（匿名）管道，它是是 UNIX 系统 IPC（进程间通信）的最古老形式，所有的 UNIX 系统都支持这种通信机制。 统计一个目录中文件的数目命令：ls | wc –l，为了执行该命令，shell 创建了两个进程来分别执行 ls 和 wc。（ ｜ 管道符） 管道的特点 管道其实是一个在内核内存中维护的缓冲器，这个缓冲器的存储能力是有限的，不同的操作系统大小不一定相同。 管道拥有文件的特质：读操作、写操作，匿名管道没有文件实体，有名管道有文件实体，但不存储数据。可以按照操作文件的方式对管道进行操作。 一个管道是一个字节流，使用管道时不存在消息或者消息边界的概念，从管道读取数据的进程可以读取任意大小的数据块，而不管写入进程写入管道的数据块的大小是多少。 通过管道传递的数据是顺序的，从管道中读取出来的字节的顺序和它们被写入管道的顺序是完全一样的。 在管道中的数据的传递方向是单向的，一端用于写入，一端用于读取，管道是半双工的。 从管道读数据是一次性操作，数据一旦被读走，它就从管道中被抛弃，释放空间以便写更多的数据，在管道中无法使用 lseek() 来随机的访问数据。 匿名管道只能在具有公共祖先的进程（父进程与子进程，或者两个兄弟进程，具有亲缘关系）之间使用。 匿名管道的使用 创建匿名管道 12345678910111213#include &lt;unistd.h&gt;int pipe(int pipefd[2]); 功能：创建一个匿名管道，用来进程间通信。 参数：int pipefd[2] 这个数组是一个传出参数。 pipefd[0] 对应的是管道的读端 pipefd[1] 对应的是管道的写端 返回值： 成功 0 失败 -1管道默认是阻塞的：如果管道中没有数据，read阻塞，如果管道满了，write阻塞注意：匿名管道只能用于具有关系的进程之间的通信（父子进程，兄弟进程） 查看管道缓冲大小命令 ulimit -a 查看管道缓冲大小函数 #include &lt;unistd.h&gt; long fpathconf(int fd, int name); 有名管道 匿名管道，由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道（FIFO），也叫命名管道、FIFO文件。 有名管道（FIFO）不同于匿名管道之处在于它提供了一个路径名与之关联，以 FIFO的文件形式存在于文件系统中，并且其打开方式与打开一个普通文件是一样的，这样即使与 FIFO 的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过 FIFO 相互通信，因此，通过 FIFO 不相关的进程也能交换数据。 一旦打开了 FIFO，就能在它上面使用与操作匿名管道和其他文件的系统调用一样的I/O系统调用了（如read()、write()和close()）。与管道一样，FIFO 也有一个写入端和读取端，并且从管道中读取数据的顺序与写入的顺序是一样的。FIFO 的名称也由此而来：先入先出。 有名管道（FIFO)和匿名管道（pipe）有一些特点是相同的，不一样的地方在于： FIFO 在文件系统中作为一个特殊文件存在，但 FIFO 中的内容却存放在内存中。 当使用 FIFO 的进程退出后，FIFO 文件将继续保存在文件系统中以便以后使用。 FIFO 有名字，不相关的进程可以通过打开有名管道进行通信。 有名管道的使用12345678910111213141516171819202122232425262728创建fifo文件1.通过命令： mkfifo 名字2.通过函数：int mkfifo(const char *pathname, mode_t mode);#include &lt;sys&#x2F;types.h&gt;#include &lt;sys&#x2F;stat.h&gt;int mkfifo(const char *pathname, mode_t mode); 参数： - pathname: 管道名称的路径 - mode: 文件的权限 和 open 的 mode 是一样的 是一个八进制的数 返回值：成功返回0，失败返回-1，并设置错误号有名管道的注意事项： 1.一个为只读而打开一个管道的进程会阻塞，直到另外一个进程为只写打开管道 2.一个为只写而打开一个管道的进程会阻塞，直到另外一个进程为只读打开管道读管道： 管道中有数据，read返回实际读到的字节数 管道中无数据： 管道写端被全部关闭，read返回0，（相当于读到文件末尾） 写端没有全部被关闭，read阻塞等待写管道： 管道读端被全部关闭，进行异常终止（收到一个SIGPIPE信号） 管道读端没有全部关闭： 管道已经满了，write会阻塞 管道没有满，write将数据写入，并返回实际写入的字节数。 一旦使用 mkfifo 创建了一个 FIFO，就可以使用 open 打开它，常见的文件I/O 函数都可用于 fifo。如：close、read、write、unlink 等。 FIFO 严格遵循先进先出（First in First out），对管道及 FIFO 的读总是从开始处返回数据，对它们的写则把数据添加到末尾。它们不支持诸如 lseek()等文件定位操作。 内存映射内存映射（Memory-mapped I/O）是将磁盘文件的数据映射到内存，用户通过修改内存就能修改磁盘文件。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;sys&#x2F;mman.h&gt;void *mmap(void *addr, size_t length, int prot, int flags,int fd, off_t offset); - 功能：将一个文件或者设备的数据映射到内存中 - 参数： - void *addr: NULL, 由内核指定 - length : 要映射的数据的长度，这个值不能为0。建议使用文件的长度。 获取文件的长度：stat lseek - prot : 对申请的内存映射区的操作权限 -PROT_EXEC ：可执行的权限 -PROT_READ ：读权限 -PROT_WRITE ：写权限 -PROT_NONE ：没有权限 要操作映射内存，必须要有读的权限。 PROT_READ、PROT_READ|PROT_WRITE - flags : - MAP_SHARED : 映射区的数据会自动和磁盘文件进行同步，进程间通信，必须要设置这个选项 - MAP_PRIVATE ：不同步，内存映射区的数据改变了，对原来的文件不会修改，会重新创建一个新的文件。（copy on write） - fd: 需要映射的那个文件的文件描述符 - 通过open得到，open的是一个磁盘文件 - 注意：文件的大小不能为0，open指定的权限不能和prot参数有冲突。 prot: PROT_READ open:只读&#x2F;读写 prot: PROT_READ | PROT_WRITE open:读写 - offset：偏移量，一般不用。必须指定的是4k的整数倍，0表示不便宜。 - 返回值：返回创建的内存的首地址 失败返回MAP_FAILED，(void *) -1int munmap(void *addr, size_t length); - 功能：释放内存映射 - 参数： - addr : 要释放的内存的首地址 - length : 要释放的内存的大小，要和mmap函数中的length参数的值一样。使用内存映射实现进程间通信：1.有关系的进程（父子进程） - 还没有子进程的时候 - 通过唯一的父进程，先创建内存映射区 - 有了内存映射区以后，创建子进程 - 父子进程共享创建的内存映射区2.没有关系的进程间通信 - 准备一个大小不是0的磁盘文件 - 进程1 通过磁盘文件创建内存映射区 - 得到一个操作这块内存的指针 - 进程2 通过磁盘文件创建内存映射区 - 得到一个操作这块内存的指针 - 使用内存映射区通信注意：内存映射区通信，是非阻塞。1.如果对mmap的返回值(ptr)做++操作(ptr++), munmap是否能够成功? void * ptr &#x3D; mmap(...); ptr++; 可以对其进行++操作 munmap(ptr, len); &#x2F;&#x2F; 错误,要保存地址 2.如果open时O_RDONLY, mmap时prot参数指定PROT_READ | PROT_WRITE会怎样? 错误，返回MAP_FAILED open()函数中的权限建议和prot参数的权限保持一致。 3.如果文件偏移量为1000会怎样? 偏移量必须是4K的整数倍，返回MAP_FAILED4.mmap什么情况下会调用失败? - 第二个参数：length &#x3D; 0 - 第三个参数：prot - 只指定了写权限 - prot PROT_READ | PROT_WRITE 第5个参数fd 通过open函数时指定的 O_RDONLY &#x2F; O_WRONLY5.可以open的时候O_CREAT一个新文件来创建映射区吗? - 可以的，但是创建的文件的大小如果为0的话，肯定不行 - 可以对新的文件进行扩展 - lseek() - truncate()6.mmap后关闭文件描述符，对mmap映射有没有影响？ int fd &#x3D; open(&quot;XXX&quot;); mmap(,,,,fd,0); close(fd); 映射区还存在，创建映射区的fd被关闭，没有任何影响。7.对ptr越界操作会怎样？ void * ptr &#x3D; mmap(NULL, 100,,,,,); 4K 越界操作操作的是非法的内存 -&gt; 段错误 信号 信号是 Linux 进程间通信的最古老的方式之一，是事件发生时对进程的通知机制，有时也称之为软中断，它是在软件层次上对中断机制的一种模拟，是一种异步通信的方式。信号可以导致一个正在运行的进程被另一个正在运行的异步进程中断，转而处理某一个突发事件。 发往进程的诸多信号，通常都是源于内核。引发内核为进程产生信号的各类事件如下： 对于前台进程，用户可以通过输入特殊的终端字符来给它发送信号。比如输入Ctrl+C通常会给进程发送一个中断信号。 硬件发生异常，即硬件检测到一个错误条件并通知内核，随即再由内核发送相应信号给相关进程。比如执行一条异常的机器语言指令，诸如被 0 除，或者引用了无法访问的内存区域。 系统状态变化，比如 alarm 定时器到期将引起 SIGALRM 信号，进程执行的 CPU时间超限，或者该进程的某个子进程退出。 运行 kill 命令或调用 kill 函数。 使用信号的两个主要目的是： 让进程知道已经发生了一个特定的事情 强迫进程执行它自己代码中的信号处理程序 信号的特点： 简单 不能携带大量信息 满足某个特定条件才发送 优先级比较高 查看系统定义的信号列表：kill -l 前31个信号为常规信号，其余为实时信号 部分信号一览 SIGINT：当用户按下了&lt;Ctrl+C&gt;组合键时，用户终端向正在运行中的由该终端启动的程序发出此信号（终止进程） SIGQUIT：用户按下&lt;Ctrl+&gt;组合键时产生该信号，用户终端向正在运行中的由该终端启动的程序发出些信号（终止进程） SIGKILL：无条件终止进程。该信号不能被忽略，处理和阻塞（终止进程，可以杀死任何进程） SIGSEGV：指示进程进行了无效内存访问(段错误) （终止进程并产生core文件） SIGPIPE：Broken pipe向一个没有读端的管道写数据 （终止进程） SIGCHLD：子进程结束时，父进程会收到这个信号 （忽略这个信号） SIGCONT：如果进程已停止，则使其继续运行（继续/忽略） SIGSTOP：停止进程的执行。信号不能被忽略，处理和阻塞（为终止进程） 信号的5种默认处理动作 查看信号的详细信息：man 7 signal 信号的5种默认处理动作 Term 终止进程 Ign 当前进程忽略掉这个信号 Core 终止进程，并生成一个Core文件 Stop 暂停当前进程 Cont 继续执行当前被暂停的进程 信号的几种状态： 产生、未决、递达 SIGKILL 和 SIGSTOP 信号不能被捕捉、阻塞或者忽略，只能执行默认动作。 信号相关的函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;sys&#x2F;types.h&gt;#include &lt;signal.h&gt;int kill(pid_t pid, int sig); - 功能：给任何的进程或者进程组pid, 发送任何的信号 sig - 参数： - pid ： &gt; 0 : 将信号发送给指定的进程 &#x3D; 0 : 将信号发送给当前的进程组 &#x3D; -1 : 将信号发送给每一个有权限接收这个信号的进程 &lt; -1 : 这个pid&#x3D;某个进程组的ID取反 （-12345） - sig : 需要发送的信号的编号或者是宏值，0表示不发送任何信号 kill(getppid(), 9); kill(getpid(), 9); int raise(int sig); - 功能：给当前进程发送信号 - 参数： - sig : 要发送的信号 - 返回值： - 成功 0 - 失败 非0 kill(getpid(), sig); void abort(void); - 功能： 发送SIGABRT信号给当前的进程，杀死当前进程 kill(getpid(), SIGABRT);unsigned int alarm(unsigned int seconds); - 功能：设置定时器（闹钟）。函数调用，开始倒计时，当倒计时为0的时候， 函数会给当前的进程发送一个信号：SIGALARM - 参数： seconds: 倒计时的时长，单位：秒。如果参数为0，定时器无效（不进行倒计时，不发信号）。 取消一个定时器，通过alarm(0)。 - 返回值： - 之前没有定时器，返回0 - 之前有定时器，返回之前的定时器剩余的时间- SIGALARM ：默认终止当前的进程，每一个进程都有且只有唯一的一个定时器。 alarm(10); -&gt; 返回0 过了1秒 alarm(5); -&gt; 返回9alarm(100) -&gt; 该函数是不阻塞的int setitimer(int which, const struct itimerval *new_value, struct itimerval *old_value); - 功能：设置定时器（闹钟）。可以替代alarm函数。精度微妙us，可以实现周期性定时 - 参数： - which : 定时器以什么时间计时 ITIMER_REAL: 真实时间，时间到达，发送 SIGALRM 常用 ITIMER_VIRTUAL: 用户时间，时间到达，发送 SIGVTALRM ITIMER_PROF: 以该进程在用户态和内核态下所消耗的时间来计算，时间到达，发送 SIGPROF - new_value: 设置定时器的属性 struct itimerval &#123; &#x2F;&#x2F; 定时器的结构体 struct timeval it_interval; &#x2F;&#x2F; 每个阶段的时间，间隔时间 struct timeval it_value; &#x2F;&#x2F; 延迟多长时间执行定时器 &#125;; struct timeval &#123; &#x2F;&#x2F; 时间的结构体 time_t tv_sec; &#x2F;&#x2F; 秒数 suseconds_t tv_usec; &#x2F;&#x2F; 微秒 &#125;; 过10秒后，每个2秒定时一次 - old_value ：记录上一次的定时的时间参数，一般不使用，指定NULL - 返回值： 成功 0 失败 -1 并设置错误号 signal信号捕捉1234567891011121314151617181920#include &lt;signal.h&gt;typedef void (*sighandler_t)(int);sighandler_t signal(int signum, sighandler_t handler); - 功能：设置某个信号的捕捉行为 - 参数： - signum: 要捕捉的信号 - handler: 捕捉到信号要如何处理 - SIG_IGN ： 忽略信号 - SIG_DFL ： 使用信号默认的行为 - 回调函数 : 这个函数是内核调用，程序员只负责写，捕捉到信号后如何去处理信号。 回调函数： - 需要程序员实现，提前准备好的，函数的类型根据实际需求，看函数指针的定义 - 不是程序员调用，而是当信号产生，由内核调用 - 函数指针是实现回调的手段，函数实现之后，将函数名放到函数指针的位置就可以了。 - 返回值： 成功，返回上一次注册的信号处理函数的地址。第一次调用返回NULL 失败，返回SIG_ERR，设置错误号 SIGKILL SIGSTOP不能被捕捉，不能被忽略。 信号集及相关函数信号集 许多信号相关的系统调用都需要能表示一组不同的信号，多个信号可使用一个称之为信号集的数据结构来表示，其系统数据类型为 sigset_t。 在 PCB 中有两个非常重要的信号集。一个称之为 “阻塞信号集” ，另一个称之为“未决信号集” 。这两个信号集都是内核使用位图机制来实现的。但操作系统不允许我们直接对这两个信号集进行位操作。而需自定义另外一个集合，借助信号集操作函数来对 PCB 中的这两个信号集进行修改。 信号的 “未决” 是一种状态，指的是从信号的产生到信号被处理前的这一段时间。 信号的 “阻塞” 是一个开关动作，指的是阻止信号被处理，但不是阻止信号产生。 信号的阻塞就是让系统暂时保留信号留待以后发送。由于另外有办法让系统忽略信号，所以一般情况下信号的阻塞只是暂时的，只是为了防止信号打断敏感的操作。 相关函数1234567891011121314151617181920212223242526272829303132333435以下信号集相关的函数都是对自定义的信号集进行操作。int sigemptyset(sigset_t *set); - 功能：清空信号集中的数据,将信号集中的所有的标志位置为0 - 参数：set,传出参数，需要操作的信号集 - 返回值：成功返回0， 失败返回-1int sigfillset(sigset_t *set); - 功能：将信号集中的所有的标志位置为1 - 参数：set,传出参数，需要操作的信号集 - 返回值：成功返回0， 失败返回-1int sigaddset(sigset_t *set, int signum); - 功能：设置信号集中的某一个信号对应的标志位为1，表示阻塞这个信号 - 参数： - set：传出参数，需要操作的信号集 - signum：需要设置阻塞的那个信号 - 返回值：成功返回0， 失败返回-1int sigdelset(sigset_t *set, int signum); - 功能：设置信号集中的某一个信号对应的标志位为0，表示不阻塞这个信号 - 参数： - set：传出参数，需要操作的信号集 - signum：需要设置不阻塞的那个信号 - 返回值：成功返回0， 失败返回-1int sigismember(const sigset_t *set, int signum); - 功能：判断某个信号是否阻塞 - 参数： - set：需要操作的信号集 - signum：需要判断的那个信号 - 返回值： 1 ： signum被阻塞 0 ： signum不阻塞 -1 ： 失败 信号处理过程 用户通过键盘 Ctrl + C, 产生2号信号SIGINT (信号被创建) 信号产生但是没有被处理 （未决） 在内核中将所有的没有被处理的信号存储在一个集合中 （未决信号集） SIGINT信号状态被存储在第二个标志位上 这个标志位的值为0， 说明信号不是未决状态 这个标志位的值为1， 说明信号处于未决状态 这个未决状态的信号，需要被处理，处理之前需要和另一个信号集（阻塞信号集），进行比较 阻塞信号集默认不阻塞任何的信号 如果想要阻塞某些信号需要用户调用系统的API 在处理的时候和阻塞信号集中的标志位进行查询，看是不是对该信号设置阻塞了 如果没有阻塞，这个信号就被处理 如果阻塞了，这个信号就继续处于未决状态，直到阻塞解除，这个信号就被处理 sigprocmask函数12345678910111213141516171819int sigprocmask(int how, const sigset_t *set, sigset_t *oldset); - 功能：将自定义信号集中的数据设置到内核中（设置阻塞，解除阻塞，替换） - 参数： - how : 如何对内核阻塞信号集进行处理 SIG_BLOCK: 将用户设置的阻塞信号集添加到内核中，内核中原来的数据不变 假设内核中默认的阻塞信号集是mask， mask | set SIG_UNBLOCK: 根据用户设置的数据，对内核中的数据进行解除阻塞 mask &amp;&#x3D; ~set SIG_SETMASK:覆盖内核中原来的值 - set ：已经初始化好的用户自定义的信号集 - oldset : 保存设置之前的内核中的阻塞信号集的状态，可以是 NULL - 返回值： 成功：0 失败：-1 设置错误号：EFAULT、EINVALint sigpending(sigset_t *set); - 功能：获取内核中的未决信号集 sigaction信号捕捉函数1234567891011121314151617181920212223242526#include &lt;signal.h&gt;int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact); - 功能：检查或者改变信号的处理。信号捕捉 - 参数： - signum : 需要捕捉的信号的编号或者宏值（信号的名称） - act ：捕捉到信号之后的处理动作 - oldact : 上一次对信号捕捉相关的设置，一般不使用，传递NULL - 返回值： 成功 0 失败 -1 struct sigaction &#123; &#x2F;&#x2F; 函数指针，指向的函数就是信号捕捉到之后的处理函数 void (*sa_handler)(int); &#x2F;&#x2F; 不常用 void (*sa_sigaction)(int, siginfo_t *, void *); &#x2F;&#x2F; 临时阻塞信号集，在信号捕捉函数执行过程中，临时阻塞某些信号。 sigset_t sa_mask; &#x2F;&#x2F; 使用哪一个信号处理对捕捉到的信号进行处理 &#x2F;&#x2F; 这个值可以是0，表示使用sa_handler,也可以是SA_SIGINFO表示使用sa_sigaction int sa_flags; &#x2F;&#x2F; 被废弃掉了 void (*sa_restorer)(void);&#125;; SIGCHLD信号产生的三个条件： 子进程结束 子进程暂停 子进程继续运行 都会给父进程发送该信号，父进程默认忽略该信号 可以使用SIGCHLD信号解决僵尸进程的问题。 共享内存共享内存允许两个或者多个进程共享物理内存的同一块区域（通常被称为段）。由于一个共享内存段会称为一个进程用户空间的一部分，因此这种 IPC 机制无需内核介入。所有需要做的就是让一个进程将数据复制进共享内存中，并且这部分数据会对其他所有共享同一个段的进程可用。 与管道等要求发送进程将数据从用户空间的缓冲区复制进内核内存和接收进程将数据从内核内存复制进用户空间的缓冲区的做法相比，这种 IPC 技术的速度更快。 共享内存使用步骤 调用 shmget() 创建一个新共享内存段或取得一个既有共享内存段的标识符（即由其他进程创建的共享内存段）。这个调用将返回后续调用中需要用到的共享内存标识符。 使用 shmat() 来附上共享内存段，即使该段成为调用进程的虚拟内存的一部分。 此刻在程序中可以像对待其他可用内存那样对待这个共享内存段。为引用这块共享内存，程序需要使用由 shmat() 调用返回的 addr 值，它是一个指向进程的虚拟地址空间中该共享内存段的起点的指针。 调用 shmdt() 来分离共享内存段。在这个调用之后，进程就无法再引用这块共享内存了。这一步是可选的，并且在进程终止时会自动完成这一步。 调用 shmctl() 来删除共享内存段。只有当当前所有附加内存段的进程都与之分离之后内存段才会销毁。只有一个进程需要执行这一步。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;sys&#x2F;ipc.h&gt;#include &lt;sys&#x2F;shm.h&gt;int shmget(key_t key, size_t size, int shmflg); - 功能：创建一个新的共享内存段，或者获取一个既有的共享内存段的标识。 新创建的内存段中的数据都会被初始化为0 - 参数： - key : key_t类型是一个整形，通过这个找到或者创建一个共享内存。 一般使用16进制表示，非0值 - size: 共享内存的大小 - shmflg: 属性 - 访问权限 - 附加属性：创建&#x2F;判断共享内存是不是存在 - 创建：IPC_CREAT - 判断共享内存是否存在： IPC_EXCL , 需要和IPC_CREAT一起使用 IPC_CREAT | IPC_EXCL | 0664 - 返回值： 失败：-1 并设置错误号 成功：&gt;0 返回共享内存的引用的ID，后面操作共享内存都是通过这个值。void *shmat(int shmid, const void *shmaddr, int shmflg); - 功能：和当前的进程进行关联 - 参数： - shmid : 共享内存的标识（ID）,由shmget返回值获取 - shmaddr: 申请的共享内存的起始地址，指定NULL，内核指定 - shmflg : 对共享内存的操作 - 读 ： SHM_RDONLY, 必须要有读权限 - 读写： 0 - 返回值： 成功：返回共享内存的首（起始）地址。 失败(void *) -1int shmdt(const void *shmaddr); - 功能：解除当前进程和共享内存的关联 - 参数： shmaddr：共享内存的首地址 - 返回值：成功 0， 失败 -1int shmctl(int shmid, int cmd, struct shmid_ds *buf); - 功能：对共享内存进行操作。删除共享内存，共享内存要删除才会消失，创建共享内存的进行被销毁了对共享内存是没有任何影响。 - 参数： - shmid: 共享内存的ID - cmd : 要做的操作 - IPC_STAT : 获取共享内存的当前的状态 - IPC_SET : 设置共享内存的状态 - IPC_RMID: 标记共享内存被销毁 - buf：需要设置或者获取的共享内存的属性信息 - IPC_STAT : buf存储数据 - IPC_SET : buf中需要初始化数据，设置到内核中 - IPC_RMID : 没有用，NULLkey_t ftok(const char *pathname, int proj_id); - 功能：根据指定的路径名，和int值，生成一个共享内存的key - 参数： - pathname:指定一个存在的路径 &#x2F;home&#x2F;nowcoder&#x2F;Linux&#x2F;a.txt &#x2F; - proj_id: int类型的值，但是这系统调用只会使用其中的1个字节 范围 ： 0-255 一般指定一个字符 &#39;a&#39;问题1：操作系统如何知道一块共享内存被多少个进程关联？ - 共享内存维护了一个结构体struct shmid_ds 这个结构体中有一个成员 shm_nattch - shm_nattach 记录了关联的进程个数问题2：可不可以对共享内存进行多次删除 shmctl - 可以的 - 因为shmctl 标记删除共享内存，不是直接删除 - 什么时候真正删除呢? 当和共享内存关联的进程数为0的时候，就真正被删除 - 当共享内存的key为0的时候，表示共享内存被标记删除了 如果一个进程和共享内存取消关联，那么这个进程就不能继续操作这个共享内存。也不能进行关联。 共享内存和内存映射的区别 共享内存可以直接创建，内存映射需要磁盘文件（匿名映射除外） 共享内存效果更高 内存 所有的进程操作的是同一块共享内存。 内存映射，每个进程在自己的虚拟地址空间中有一个独立的内存。 数据安全 进程突然退出 共享内存还存在 内存映射区消失 运行进程的电脑死机，宕机了 数据存在在共享内存中，没有了 内存映射区的数据 ，由于磁盘文件中的数据还在，所以内存映射区的数据还存在。 生命周期 内存映射区：进程退出，内存映射区销毁 共享内存：进程退出，共享内存还在，标记删除（所有的关联的进程数为0），或者关机 如果一个进程退出，会自动和共享内存进行取消关联。 共享内存操作命令 ipcs 用法  ipcs -a // 打印当前系统中所有的进程间通信方式的信息  ipcs -m // 打印出使用共享内存进行进程间通信的信息  ipcs -q // 打印出使用消息队列进行进程间通信的信息  ipcs -s // 打印出使用信号进行进程间通信的信息 ipcrm 用法  ipcrm -M shmkey // 移除用shmkey创建的共享内存段  ipcrm -m shmid // 移除用shmid标识的共享内存段  ipcrm -Q msgkey // 移除用msqkey创建的消息队列  ipcrm -q msqid // 移除用msqid标识的消息队列  ipcrm -S semkey // 移除用semkey创建的信号  ipcrm -s semid // 移除用semid标识的信号 守护进程终端 在 UNIX 系统中，用户通过终端登录系统后得到一个 shell 进程，这个终端成为 shell 进程的控制终端（Controlling Terminal），进程中，控制终端是保存在 PCB 中的信息，而 fork() 会复制 PCB 中的信息，因此由 shell 进程启动的其它进程的控制终端也是这个终端。 默认情况下（没有重定向），每个进程的标准输入、标准输出和标准错误输出都指向控制终端，进程从标准输入读也就是读用户的键盘输入，进程往标准输出或标准错误输出写也就是输出到显示器上。 在控制终端输入一些特殊的控制键可以给前台进程发信号，例如 Ctrl + C 会产生 SIGINT 信号，Ctrl + \\ 会产生 SIGQUIT 信号。 进程组 进程组和会话在进程之间形成了一种两级层次关系：进程组是一组相关进程的集合，会话是一组相关进程组的集合。进程组和会话是为支持 shell 作业控制而定义的抽象概念，用户通过 shell 能够交互式地在前台或后台运行命令。 进行组由一个或多个共享同一进程组标识符（PGID）的进程组成。一个进程组拥有一个进程组首进程，该进程是创建该组的进程，其进程 ID 为该进程组的 ID，新进程会继承其父进程所属的进程组 ID。 进程组拥有一个生命周期，其开始时间为首进程创建组的时刻，结束时间为最后一个成员进程退出组的时刻。一个进程可能会因为终止而退出进程组，也可能会因为加入了另外一个进程组而退出进程组。进程组首进程无需是最后一个离开进程组的成员。 会话 会话是一组进程组的集合。会话首进程是创建该新会话的进程，其进程 ID 会成为会话 ID。新进程会继承其父进程的会话 ID。 一个会话中的所有进程共享单个控制终端。控制终端会在会话首进程首次打开一个终端设备时被建立。一个终端最多可能会成为一个会话的控制终端。 在任一时刻，会话中的其中一个进程组会成为终端的前台进程组，其他进程组会成为后台进程组。只有前台进程组中的进程才能从控制终端中读取输入。当用户在控制终端中输入终端字符生成信号后，该信号会被发送到前台进程组中的所有成员。 当控制终端的连接建立起来之后，会话首进程会成为该终端的控制进程。 进程组、会话、控制终端之间的关系 进程组、会话操作函数 pid_t getpgrp(void); pid_t getpgid(pid_t pid); int setpgid(pid_t pid, pid_t pgid); pid_t getsid(pid_t pid); pid_t setsid(void); 守护进程 守护进程（Daemon Process），也就是通常说的 Daemon 进程（精灵进程），是Linux 中的后台服务进程。它是一个生存期较长的进程，通常独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。一般采用以 d 结尾的名字。 守护进程具备下列特征： 生命周期很长，守护进程会在系统启动的时候被创建并一直运行直至系统被关闭。 它在后台运行并且不拥有控制终端。没有控制终端确保了内核永远不会为守护进程自动生成任何控制信号以及终端相关的信号（如 SIGINT、SIGQUIT）。 Linux 的大多数服务器就是用守护进程实现的。比如，Internet 服务器 inetd，Web 服务器 httpd 等。 守护进程的创建步骤 执行一个 fork()，之后父进程退出，子进程继续执行。 子进程调用 setsid() 开启一个新会话。 清除进程的 umask 以确保当守护进程创建文件和目录时拥有所需的权限。 修改进程的当前工作目录，通常会改为根目录（/）。 关闭守护进程从其父进程继承而来的所有打开着的文件描述符。 在关闭了文件描述符0、1、2之后，守护进程通常会打开/dev/null 并使用dup2()使所有这些描述符指向这个设备。 核心业务逻辑","categories":[],"tags":[{"name":"Linux，多进程","slug":"Linux，多进程","permalink":"http://yoursite.com/tags/Linux%EF%BC%8C%E5%A4%9A%E8%BF%9B%E7%A8%8B/"}]},{"title":"Linux系统编程笔记","slug":"Linux系统编程笔记","date":"2021-03-31T00:44:51.000Z","updated":"2021-03-31T00:51:51.861Z","comments":true,"path":"2021/03/31/Linux系统编程笔记/","link":"","permalink":"http://yoursite.com/2021/03/31/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/","excerpt":"库库文件是计算机上的一类文件，可以简单的把库文件看成一种代码仓库，它提供给使用者一些直接拿来用的变量、函数或类。库不能单独运行。 静态库：在程序链接阶段被复制到程序中 动态库：在链接阶段没有被复制到程序中，而是程序在运行时由系统动态加载到内存中供程序调用","text":"库库文件是计算机上的一类文件，可以简单的把库文件看成一种代码仓库，它提供给使用者一些直接拿来用的变量、函数或类。库不能单独运行。 静态库：在程序链接阶段被复制到程序中 动态库：在链接阶段没有被复制到程序中，而是程序在运行时由系统动态加载到内存中供程序调用 库的好处： 代码保密 方便部署和分发 静态库命名规则： Linux：libxxx.a lib: 前缀（固定） xxx：库的名字，自己起 .a：后缀（固定） windows：libxxx.lib 静态库的制作： gcc获得.o文件 将.o文件打包，使用ar工具（archive） ar rcs libxxx.a .o xxx.o xxx.o r - 将文件插入备存文件中 c - 建立备存文件 s - 索引 动态库命名规则： Linux：libxxx.so windows: libxxx.dll 动态库的制作： gcc -c -fpic/fPIC 获得.o 文件 gcc -shared *.o -o libxxx.so 程序启动后，动态库会被动态加载到内存中，通过ldd(list dynamic dependencies)命令检查动态库依赖关系。 解决动态库加载失败的问题 修改DT_RPATH ，临时的 修改环境变量LD_LIBRARY_PATH 修改/etc/ld.so.cache文件列表 修改/lib/, /usr/lib 静态库和动态库的对比 静态库、动态库区别来自链接阶段如何处理，分别称为静态链接方式和动态链接方式 静态库的优缺点 优点： 静态库打包到应用程序中加载速度快 发布程序无需提供静态库，移植方便 缺点： 消耗系统资源，浪费内存 更新、部署、发布麻烦 动态库的优缺点 优点： 可以实现进程间资源共享（共享库） 更新、部署、发布简单 可以控制何时加载动态库 缺点： 加载速度比静态库慢 发布程序时需要提供依赖的动态库 MakefileMakefile规则 一个 Makefile 文件中可以有一个或者多个规则 目标…：依赖… 命令（shell命令） … 目标：最终要生成的文件（伪目标除外） 依赖：生成目标所需要的文件或是目标 命令：通过执行命令对依赖操作生成目标（命令前必须 Tab 缩进） Makefile 中的其它规则一般都是为第一条规则服务的。 工作原理 命令在执行之前，需要先检查规则中的依赖是否存在 如果存在，执行命令 如果不存在，向下检查其它的规则，检查有没有一个规则是用来生成这个依赖的，如果找到了，则执行该规则中的命令 检测更新，在执行规则中的命令时，会比较目标和依赖文件的时间 如果依赖的时间比目标的时间晚，需要重新生成目标 如果依赖的时间比目标的时间早，目标不需要更新，对应规则中的命令不需要被执行 GDB 通常，在为调试而编译时，我们会（）关掉编译器的优化选项（-O）， 并打开调试选项（-g）。另外，-Wall在尽量不影响程序行为的情况下选项打开所有warning，也可以发现许多问题，避免一些不必要的 BUG。 gcc -g -Wall program.c -o program -g 选项的作用是在可执行文件中加入源代码的信息，比如可执行文件中第几条机器指令对应源代码的第几行，但并不是把整个源文件嵌入到可执行文件中，所以在调试时必须保证 gdb 能找到源文件。 标准C库函数和Linux系统函数 标准C库IO和Linux系统IO的关系 虚拟地址空间 文件描述符 File Descriptor内核（kernel）利用文件描述符（file descriptor）来访问文件。文件描述符是非负整数。打开现存文件或新建文件时，内核会返回一个文件描述符。读写文件也需要使用文件描述符来指定待读写的文件。 Linux 系统IO函数 int open(const char *pathname, int flags); 打开文件 flags 如 O_CREAT，意思是没有即创建 int open(const char *pathname, int flags, mode_t mode); 打开文件，并设置模式 mode 可以是 O_RDONLY, O_WRONLY, O_RDWR int close(int fd); 关闭文件描述符 ssize_t read(int fd, void *buf, size_t count); ssize_t write(int fd, const void *buf, size_t count); off_t lseek(int fd, off_t offset, int whence); 重定位文件偏移量 SEEK_SET：设置offset SEEK_CUR：设置offset为当前加上传的参数offset SEEK_END：设置offset为文件末端加上传的参数offset（记得之后要写入一些字符才能更新） int stat(const char *pathname, struct stat *statbuf); 得到文件状态信息 int lstat(const char *pathname, struct stat *statbuf); 得到软连接文件状态信息 文件属性操作函数 int access(const char *pathname, int mode); 判断文件mode int chmod(const char *filename, int mode); int chown(const char *path, uid_t owner, gid_t group); int truncate(const char *path, off_t length); 截断或延长文件长度 目录操作函数 int rename(const char *oldpath, const char *newpath); int chdir(const char *path); char *getcwd(char *buf, size_t size); int mkdir(const char *pathname, mode_t mode); int rmdir(const char *pathname); 目录遍历函数 DIR *opendir(const char *name); 返回目录流 struct dirent *readdir(DIR *dirp); 返回direct结构体，目录流文件的信息 int closedir(DIR *dirp); dup, dup2 函数 int dup(int oldfd); 复制文件描述符 int dup2(int oldfd, int newfd); 重定向文件描述符 fcntl函数 int fcntl(int fd, int cmd, … /* arg */ ); 复制文件描述符 设置/获取文件的状态标志","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"重载、重写（覆盖）、隐藏的区别","slug":"重载、重写（覆盖）、隐藏的区别","date":"2021-03-20T21:53:30.000Z","updated":"2021-03-20T22:04:09.373Z","comments":true,"path":"2021/03/20/重载、重写（覆盖）、隐藏的区别/","link":"","permalink":"http://yoursite.com/2021/03/20/%E9%87%8D%E8%BD%BD%E3%80%81%E9%87%8D%E5%86%99%EF%BC%88%E8%A6%86%E7%9B%96%EF%BC%89%E3%80%81%E9%9A%90%E8%97%8F%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"概念解释 重载：是指同一可访问区内被声明几个具有不同参数列（参数的类型、个数、顺序）的同名函数，根据参数列表确定调用哪个函数，重载不关心函数返回类型。","text":"概念解释 重载：是指同一可访问区内被声明几个具有不同参数列（参数的类型、个数、顺序）的同名函数，根据参数列表确定调用哪个函数，重载不关心函数返回类型。 隐藏：是指派生类的函数屏蔽了与其同名的基类函数，主要只要同名函数，不管参数列表是否相同，基类函数都会被隐藏。 重写（覆盖）：是指派生类中存在重新定义的函数。函数名、参数列表、返回值类型都必须同基类中被重写的函数一致，只有函数体不同。派生类调用时会调用派生类的重写函数，不会调用被重写函数。重写的基类中被重写的函数必须有 virtual 修饰。 重写和重载的区别： 范围区别：对于类中函数的重载或者重写而言，重载发生在同一个类的内部，重写发生在不同的类之间。 参数区别：重载的函数需要与原函数有相同的函数名、不同的参数列表，不关心函数的返回值类型；重写的函数的函数名、参数列表和返回值类型都需要与原函数相同，父类中被重写的函数需要有 virtual 修饰。 virtual 关键字：重写的函数基类中必须有 virtual 关键字的修饰，重载的函数可以有 virtual 关键字的修饰也可以没有。 隐藏和重写，重载的区别： 范围区别：隐藏发生在不同类中。 参数区别：隐藏函数和被隐藏函数只需要函数名相同；当参数不同时，无论基类中的函数是否被 virtual 修饰，基类函数都是被隐藏，而不是重写。","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"weak_ptr是如何解决循环引用的","slug":"weak_ptr是如何解决循环引用的","date":"2021-03-20T11:54:24.000Z","updated":"2021-03-20T21:40:59.925Z","comments":true,"path":"2021/03/20/weak_ptr是如何解决循环引用的/","link":"","permalink":"http://yoursite.com/2021/03/20/weak_ptr%E6%98%AF%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E7%9A%84/","excerpt":"C++11中智能指针包括三种：共享指针(shared_ptr)，独占指针(unique_ptr)，弱指针(weak_ptr)。 智能指针通过计数原理来实现，但在使用过程中可能会出现循环引用的问题，我们可以通过weak_ptr去解决。","text":"C++11中智能指针包括三种：共享指针(shared_ptr)，独占指针(unique_ptr)，弱指针(weak_ptr)。 智能指针通过计数原理来实现，但在使用过程中可能会出现循环引用的问题，我们可以通过weak_ptr去解决。 出现循环引用的举例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt;#include &lt;memory&gt;using namespace std;class Child;class Parent;class Parent &#123;private: shared_ptr&lt;Child&gt; ChildPtr;public: void setChild(shared_ptr&lt;Child&gt; child) &#123; this-&gt;ChildPtr = child; &#125; void doSomething() &#123; if (this-&gt;ChildPtr.use_count()) &#123; &#125; &#125; ~Parent() &#123; &#125;&#125;;class Child &#123;private: shared_ptr&lt;Parent&gt; ParentPtr;public: void setPartent(shared_ptr&lt;Parent&gt; parent) &#123; this-&gt;ParentPtr = parent; &#125; void doSomething() &#123; if (this-&gt;ParentPtr.use_count()) &#123; &#125; &#125; ~Child() &#123; &#125;&#125;;int main() &#123; weak_ptr&lt;Parent&gt; wpp; weak_ptr&lt;Child&gt; wpc; &#123; shared_ptr&lt;Parent&gt; p(new Parent); shared_ptr&lt;Child&gt; c(new Child); p-&gt;setChild(c); c-&gt;setPartent(p); wpp = p; wpc = c; cout &lt;&lt; p.use_count() &lt;&lt; endl; // 2 cout &lt;&lt; c.use_count() &lt;&lt; endl; // 2 &#125; cout &lt;&lt; wpp.use_count() &lt;&lt; endl; // 1 cout &lt;&lt; wpc.use_count() &lt;&lt; endl; // 1 return 0;&#125; 在如下例子中定义了两个类 Parent、Child，在两个类中分别定义另一个类的对象的共享指针，由于在程序结束后，两个指针相互指向对方的内存空间，导致内存无法释放。 使用weak_ptr解决循环引用因为weak_ptr的作用是绑定到一个智能指针上，但不会影响该指针的计数，所以我们只需要在原本的循环引用中，令其中一环为weak_ptr即可打破这个闭环。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#include &lt;memory&gt;using namespace std;class Child;class Parent;class Parent &#123;private: //shared_ptr&lt;Child&gt; ChildPtr; weak_ptr&lt;Child&gt; ChildPtr;public: void setChild(shared_ptr&lt;Child&gt; child) &#123; this-&gt;ChildPtr = child; &#125; void doSomething() &#123; //new shared_ptr if (this-&gt;ChildPtr.lock()) &#123; &#125; &#125; ~Parent() &#123; &#125;&#125;;class Child &#123;private: shared_ptr&lt;Parent&gt; ParentPtr;public: void setPartent(shared_ptr&lt;Parent&gt; parent) &#123; this-&gt;ParentPtr = parent; &#125; void doSomething() &#123; if (this-&gt;ParentPtr.use_count()) &#123; &#125; &#125; ~Child() &#123; &#125;&#125;;int main() &#123; weak_ptr&lt;Parent&gt; wpp; weak_ptr&lt;Child&gt; wpc; &#123; shared_ptr&lt;Parent&gt; p(new Parent); shared_ptr&lt;Child&gt; c(new Child); p-&gt;setChild(c); c-&gt;setPartent(p); wpp = p; wpc = c; cout &lt;&lt; p.use_count() &lt;&lt; endl; // 2 cout &lt;&lt; c.use_count() &lt;&lt; endl; // 1 &#125; cout &lt;&lt; wpp.use_count() &lt;&lt; endl; // 0 cout &lt;&lt; wpc.use_count() &lt;&lt; endl; // 0 return 0;&#125; 为什么在访问weak_ptr所指的对象时，要先转为shared_ptr?","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"指针","slug":"指针","permalink":"http://yoursite.com/tags/%E6%8C%87%E9%92%88/"},{"name":"智能指针","slug":"智能指针","permalink":"http://yoursite.com/tags/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"}]},{"title":"C++内存管理及栈、堆区别","slug":"C++内存管理及栈、堆区别","date":"2021-03-20T09:54:45.000Z","updated":"2021-03-20T10:08:37.719Z","comments":true,"path":"2021/03/20/C++内存管理及栈、堆区别/","link":"","permalink":"http://yoursite.com/2021/03/20/C++%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%8F%8A%E6%A0%88%E3%80%81%E5%A0%86%E5%8C%BA%E5%88%AB/","excerpt":"C++内存分区 栈：存放函数的局部变量、函数参数、返回地址等，由编译器自动分配 堆：动态申请的内存空间，就是由malloc分配的内存块，由程序员控制它的分配和释放，如果程序结束还没有释放，操作系统会自动回收","text":"C++内存分区 栈：存放函数的局部变量、函数参数、返回地址等，由编译器自动分配 堆：动态申请的内存空间，就是由malloc分配的内存块，由程序员控制它的分配和释放，如果程序结束还没有释放，操作系统会自动回收 全局区/静态存储区（.bss段和.data段）：存放全局变量和静态变量，程序运行结束操作系统自动释放 常量存储区：存放的是常量，不允许修改，程序运行结束自动释放 代码区：存放代码，不允许修改，但可以执行。编译后的二进制文件存放在这里 栈和堆的区别 申请方式：栈是系统自动分配，堆是程序员主动申请 申请后系统响应：分配栈空间，如果剩余空间大于申请空间则分配成功，否则分配失败栈溢出；申请堆空间，堆在内存中呈现方式类似于链表（记录空闲地址空间的链表），在链表上寻找第一个大于申请空间的节点分配给程序，将该节点从链表中删除，大多数系统中该块空间的首地址存放的是本次分配空间的大小，便于释放，将该块空间上的剩余空间再次连接在空闲链表上。 栈在内存中是连续的一块空间（向低地址扩展）最大容量是系统预定好的，堆在内存中的空间（向高地址扩展）是不连续的。 申请效率：栈是由系统自动分配，申请效率高，但程序员无法控制；堆是由程序员自己来申请的，效率低，容易产生碎片。 存放的内容：栈中存放的是局部变量，函数的参数；堆中存放的内容由程序员控制。","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"C++类对象的初始化顺序","slug":"C++类对象的初始化顺序","date":"2021-03-19T23:28:20.000Z","updated":"2021-03-19T23:34:55.118Z","comments":true,"path":"2021/03/19/C++类对象的初始化顺序/","link":"","permalink":"http://yoursite.com/2021/03/19/C++%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F/","excerpt":"构造函数调用顺序： 按照派生类继承基类的顺序，即派生列表中声明的顺序，依次调用基类的构造函数； 按照派生类中成员变量的声明顺序，依次调用派生类中成员变量所属类的构造函数； 执行派生类自身的构造函数。","text":"构造函数调用顺序： 按照派生类继承基类的顺序，即派生列表中声明的顺序，依次调用基类的构造函数； 按照派生类中成员变量的声明顺序，依次调用派生类中成员变量所属类的构造函数； 执行派生类自身的构造函数。 综上可知，类对象的初始化顺序：基类构造函数-&gt;派生类成员变量的构造函数-&gt;自身构造函数。 基类构造函数的调用顺序与派生类的派生列表的顺序有关； 成员变量的初始化顺序与声明顺序有关； 析构顺序和构造顺序相反。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;using namespace std;class A&#123;public: A() &#123; cout &lt;&lt; &quot;A()&quot; &lt;&lt; endl; &#125; ~A() &#123; cout &lt;&lt; &quot;~A()&quot; &lt;&lt; endl; &#125;&#125;;class B&#123;public: B() &#123; cout &lt;&lt; &quot;B()&quot; &lt;&lt; endl; &#125; ~B() &#123; cout &lt;&lt; &quot;~B()&quot; &lt;&lt; endl; &#125;&#125;;class Test : public A, public B // 派生列表&#123;public: Test() &#123; cout &lt;&lt; &quot;Test()&quot; &lt;&lt; endl; &#125; ~Test() &#123; cout &lt;&lt; &quot;~Test()&quot; &lt;&lt; endl; &#125;private: B ex1; A ex2;&#125;;int main()&#123; Test ex; return 0;&#125;/*运行结果：A()B()B()A()Test()~Test()~A()~B()~B()~A()*/","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"类","slug":"类","permalink":"http://yoursite.com/tags/%E7%B1%BB/"}]},{"title":"C++的构造函数为什么不能是虚函数，而基类的析构函数必须是虚函数","slug":"C++的构造函数为什么不能是虚函数，而基类的析构函数必须是虚函数","date":"2021-03-19T22:08:59.000Z","updated":"2021-03-19T22:30:00.192Z","comments":true,"path":"2021/03/19/C++的构造函数为什么不能是虚函数，而基类的析构函数必须是虚函数/","link":"","permalink":"http://yoursite.com/2021/03/19/C++%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E6%98%AF%E8%99%9A%E5%87%BD%E6%95%B0%EF%BC%8C%E8%80%8C%E5%9F%BA%E7%B1%BB%E7%9A%84%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E5%BF%85%E9%A1%BB%E6%98%AF%E8%99%9A%E5%87%BD%E6%95%B0/","excerpt":"构造函数为什么不能是虚函数呢？首先我们需要知道两个概念，以及这两者之间的关联： 虚表指针vptr 虚函数表","text":"构造函数为什么不能是虚函数呢？首先我们需要知道两个概念，以及这两者之间的关联： 虚表指针vptr 虚函数表 vptr指针指向虚函数表，执行虚函数的时候，会调用vptr指针指向的虚函数的地址。 当定义一个对象的时候，首先会分配对象内存空间，然后调用构造函数来初始化对象。vptr变量是在构造函数中进行初始化的。又因为执行虚函数需要通过vptr指针来调用。如果可以定义构造函数为虚函数，那么这将陷入死锁。 基类的析构函数为什么必须是虚函数呢？我们想要回收一个对象申请的资源，就需要调用析构函数。虽然我们没有显示调用析构函数，但是编译器会默认地为我们执行析构函数。 那么当我们执行 BaseClass *base = new BaseClass(); 当我们执行 delete base 时，会调用析构函数为我们释放资源。而我们执行 BaseClass *sub = new SubClass(); 如果BaseClass基类的析构函数不是虚函数的时候，delete sub 对象的时候，只会释放 BaseClass 基类申请的资源，而不是释放 SubClass 派生类的资源，原因如下： 基类指针指向了派生类对象，而基类中的析构函数是非virtual的，而虚函数是动态绑定的基础。现在析构函数不是virtual的，因此不会发生动态绑定，而是静态绑定，指针的静态类型为基类指针，因此在delete的时候只会调用基类的析构函数，而不会调用派生类的析构函数。这样，在派生类中申请的资源就不会得到释放，就会造成内存泄漏。","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"虚函数","slug":"虚函数","permalink":"http://yoursite.com/tags/%E8%99%9A%E5%87%BD%E6%95%B0/"}]},{"title":"Python time, random, collections, itertools基本用法","slug":"Python-time-random-collections-itertools基本用法","date":"2020-10-28T11:35:26.000Z","updated":"2020-10-28T11:40:02.995Z","comments":true,"path":"2020/10/28/Python-time-random-collections-itertools基本用法/","link":"","permalink":"http://yoursite.com/2020/10/28/Python-time-random-collections-itertools%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/","excerpt":"Python time, random, collections, itertools 的基本用法","text":"Python time, random, collections, itertools 的基本用法 time库import time Python处理时间的标准库 time.localtime() 本地时间 time.gmtime() UTC世界统一时间，北京时间比这个统一时间早8个小时 time.ctime() 返回本地时间的字符串 时间戳和计时器 time.time() 返回自纪元以来的秒数，记录time.sleep() time.perf_counter() 随意取一个时间点到该时间点的间隔秒数，记录sleep time.process_time() 随意取，不记录sleep 格式化time.strftime自定义格式化输出 12lctime = time.localtime()time.strftime(&quot;%Y-%m-%d %A %H:%M:%S&quot;, lctime) sleeptime.sleep() 以秒为单位 random库Python通过random库提供各种伪随机数 随机种子——seed(a=None) 相同的种子会产生相同的随机数 如果不设置随机种子，以系统当前时间为默认值 产生随机整数 randint(a, b) 产生[a,b]之间 randrange(a) 产生[0,a) randrange(a, b, step) 产生[a, b), 以step为步长 产生随机浮点数 random() 产生[0.0,1.0) uniform(a, b) 产生[a, b] 序列用函数 choice(seq) 从seq返回一个 choices(seq, weights=None, k) 对seq进行k次，可设置权重 shuffle(seq) 将seq随机排列 sample(pop, k) 从pop中随机可，以列表返回，k不能超过len(pop) 概率分布guess(mean, std) collecitons库import collecitons nametuplecollecitons.nametuple(typename, field_names, *, rename=False, default=None, module=None) 12345678910Point = collecitons.nametuple(&quot;Point&quot;, [&quot;x&quot;, &quot;y&quot;])p = Point(1, y=2)p # Point(x=1, y=2)# 可以调用属性print(p.x) # 1# 有元组的性质print(p[0]) # 1x, y = pprint(x) # 1 Counterfrom collecitons import Counter 计数统计 Counter.most_common(n) 最常见的n个 Counter.elements() 展开 deque双向队列 append() appendleft() pop() popleft() itertools库排列组合迭代器 product——笛卡尔积 product(‘ABC’, “01”) product(‘ABC’, repeat = 3) permutations——排列 permutations(range(3)) combinations——组合 combinations(‘abcd’, 2) combinations(range(4), 3) combinations_with_replacement——元素可重复组合 拉链 zip——短拉链 zip(‘abc’, ‘012’, ‘xyz’) 长度不一时，执行到最短的对象处就停止 zip_longest——长拉链 zip_longest(‘abc’, ‘012345’, fillvalue=”?”) 长度不一时，执行到最长的对象处就停止，缺省元素用None或指定的字符替代 无穷迭代器 count(start=0, step=1) 计数 cycle(iterable) 循环 repeat(object, times) 重复 chain(iterables) 锁链 enumerate(iterable, start=0)——枚举（内置） 产出有两个元素组成的元组， 结构式(index, item)，其中index从start开始，item从iterable中取 12for i in enumerate(&quot;pyhton&quot;, start = 1): print(i) groupby(iterable, key=None)——分组 创建一个迭代器，按照key指定的方式，返回iterable中连续的键和组，一般来说要预先对数据进行排序，key为None默认把连续重复元素分组","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"算法中的差分思想","slug":"算法中的差分思想","date":"2020-09-21T14:48:59.000Z","updated":"2020-09-21T14:48:59.343Z","comments":true,"path":"2020/09/21/算法中的差分思想/","link":"","permalink":"http://yoursite.com/2020/09/21/%E7%AE%97%E6%B3%95%E4%B8%AD%E7%9A%84%E5%B7%AE%E5%88%86%E6%80%9D%E6%83%B3/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"C++中的const成员函数","slug":"C++中的const成员函数","date":"2020-09-21T14:43:13.000Z","updated":"2020-10-01T11:18:08.673Z","comments":true,"path":"2020/09/21/C++中的const成员函数/","link":"","permalink":"http://yoursite.com/2020/09/21/C++%E4%B8%AD%E7%9A%84const%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/","excerpt":"我们在定义类的成员函数的时候，往往函数块内会返回一个其他的成员，这种方式实际上是隐式地指向调用该函数的对象的成员，即成员函数通过一个名为this的额外的隐式参数来访问调用它的那个对象。 而我们往往会看到成员函数的参数列表后紧跟着一个const关键字，这个const的作用是修改隐式this指针的类型。","text":"我们在定义类的成员函数的时候，往往函数块内会返回一个其他的成员，这种方式实际上是隐式地指向调用该函数的对象的成员，即成员函数通过一个名为this的额外的隐式参数来访问调用它的那个对象。 而我们往往会看到成员函数的参数列表后紧跟着一个const关键字，这个const的作用是修改隐式this指针的类型。 默认情况下来说，this的类型是指向类类型的非常量版本的指针，可以表示为 struct_name *const, 尽管this是隐式的，但它仍需要遵循初始化原则，这就意味值默认情况下this指针是不能绑定到一个常量对象上的，这也就意味着我们不能在一个常量对象上调用普通成员函数。 123456789101112131415161718// 简单定义一个类struct help&#123; int a; int b; help(int aa, int bb) &#123; a = aa; b = bb; &#125; int helper() &#123; return a; &#125;&#125;;int main(int argc, const char * argv[]) &#123; const help temp(12, 23); // 声明一个常量类对象 int c = temp.helper(); // 错误，因为help()是一个普通成员函数，所以this是指向一个非常量对象，而temp又是一个常量对象，所以会报错 cout &lt;&lt; c &lt;&lt; endl;&#125; 所以在这种情况下，我们应该把this声明为 const struct_name *const 这样就可以解决问题，但又因为this是隐式的，所以我们可以将成员函数的声明改为： 1int helper() const &#123;&#125; 这样就可以将this声明为指向常量对象的版本了。而这种使用const的成员函数也叫做常量成员函数(const member function)。","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"C++中的顶层const和底层const","slug":"C++中的顶层const和底层const","date":"2020-09-01T10:40:27.000Z","updated":"2020-09-21T14:52:36.222Z","comments":true,"path":"2020/09/01/C++中的顶层const和底层const/","link":"","permalink":"http://yoursite.com/2020/09/01/C++%E4%B8%AD%E7%9A%84%E9%A1%B6%E5%B1%82const%E5%92%8C%E5%BA%95%E5%B1%82const/","excerpt":"​ const对象一旦创建后其值就不能再改变。而对于指针这种本身是一个对象，它又可以指向另一个对象的情况时，指针本身是不是常量以及指针所指的是不是一个常量就是两个相互独立的问题了，用名词顶层const(top-level const)表示指针本身是个常量，而用底层const(low-level const)表示指针所指的对象是一个常量。","text":"​ const对象一旦创建后其值就不能再改变。而对于指针这种本身是一个对象，它又可以指向另一个对象的情况时，指针本身是不是常量以及指针所指的是不是一个常量就是两个相互独立的问题了，用名词顶层const(top-level const)表示指针本身是个常量，而用底层const(low-level const)表示指针所指的对象是一个常量。 top-level const 的一些演示1234567//初始化两个非常量int i1 = 20; int i2 = 30;//初始化一个顶层const指针，这个操作意味着指针本身的值是一个常量，其本身是不可以改变的，而指针所指的值是一个非常量是可以改变的int *const p = &amp;i1;p = &amp;i2; //错误。指针p本身是一个常量，是不可以改变的*p = i2; //正确。指针所指的值并不是一个常量，是可以改变的 low-level const 的一些演示1234567//初始化两个非常量int i1 = 20;int i2 = 30;//初始化一个底层const指针，这个操作意味着这个指针指向一个常量，不可以通过该指针去改变指针所指的对象，但指针本身是可以更改的const int *p = &amp;i1;*p = i2; //错误。指针p所指的是一个常量，不可以通过指针去修改其指向的对象p = &amp;i2; //正确。指针本身不是常量，可以修改指针本身 ​ 上面的展示应该很清楚地展示了顶层const和底层const的区别所在，当然我们也可以将一个指针声明为既是底层cosnt亦是顶层const，这样我们就不可以通过指针去修改指针所指的对象，也不可以修改指针本身，其声明方式如下。 1234567//初始化两个非常量int i1 = 20;int i2 = 30;//初始化一个既是底层const也是顶层const的指针const int *const p = &amp;i1;*p = i2; //错误。指针p是一个底层const，其所指的对象是一个常量。p = &amp;i2; //错误。指针p是一个顶层const，其本身是一个常量。 所谓的指向常量的指针(pointer to const)只是指针自己以为自己指向的是常量​ 为什么上面的例子都是初始化两个非常量呢？因为其实对于指向常量的指针来说（意思是底层const），只是指针自以为自己指向的是一个常量，所以指针自觉地不去改变所指的对象。但其实指向常量的指针没有规定其所指的对象必须是一个常量。 12345678//初始化两个非常量int i1 = 20;int i2 = 30;//初始化一个底层const指针，即指向常量的指针const int *p = &amp;i1;*p = i2; //错误。指针认为自己指向的是常量，不能通过自己去改变所指的对象i1 = i2; //正确。指向常量的指针没有规定所指的对象是一个常量，所以可以直接修改非常量对象本身std::cout &lt;&lt; *p; //将会打印&quot;30&quot;，而不是&quot;20&quot; 指针和constexpr​ C++11中，允许将变量声明为constexpr类型以便由编译器来验证变量的值是否是一个常量表达式。但必须明确一点，在constexpr声明中如果定义了一个指针，限定符constexpr仅对指针有效，与指针所指的对象无关。意思就是通过constexpr定义的指针是一个顶层const。 1234constexpr int i = 20; //定义一个常量int j = 100; //定义一个非常量constexpr int *p = &amp;i; //错误。p本身是一个常量，但p所指的不是一个常量，所以p不能指向一个常量整数constexpr int *p = &amp;j; //正确。p本身是一个常量指针，指向一个整数","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"指针","slug":"指针","permalink":"http://yoursite.com/tags/%E6%8C%87%E9%92%88/"},{"name":"const","slug":"const","permalink":"http://yoursite.com/tags/const/"}]},{"title":"对KMP算法的一些理解","slug":"对KMP算法的一些理解","date":"2020-08-24T01:14:10.000Z","updated":"2020-08-29T13:07:55.033Z","comments":true,"path":"2020/08/24/对KMP算法的一些理解/","link":"","permalink":"http://yoursite.com/2020/08/24/%E5%AF%B9KMP%E7%AE%97%E6%B3%95%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/","excerpt":"KMP算法是一种字符串匹配算法，可以在O(n+m)时间复杂度内实现两个字符串的匹配。","text":"KMP算法是一种字符串匹配算法，可以在O(n+m)时间复杂度内实现两个字符串的匹配。 关于字符串匹配暴力解决字符串匹配即通过两个串的每个字符逐一比较，python实现如下： 1234def match(S, P): for i in range(len(S) - len(P) + 1): if S[i:i+len(P)] == P: return i 如果 n = len(S), m = len(P)。那么最坏的情况下，暴力解法的时间复杂度能去到O(nm)。 暴力解法并没有利用字符串匹配过程中残留的一部分信息，而KMP算法则是通过“尽可能减少比较的趟数”来做到优化，即看看能否在匹配失败后，跳过一部分不可能成功的字符串比较来使复杂度降低。 简述KMP起始思路","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/tags/algorithm/"}]},{"title":"vimKeyboard","slug":"vimKeyboard","date":"2020-08-23T13:19:30.000Z","updated":"2020-08-23T13:19:30.000Z","comments":true,"path":"2020/08/23/vimKeyboard/","link":"","permalink":"http://yoursite.com/2020/08/23/vimKeyboard/","excerpt":"","text":"vim键位图","categories":[],"tags":[{"name":"vim","slug":"vim","permalink":"http://yoursite.com/tags/vim/"}]}],"categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"},{"name":"select","slug":"select","permalink":"http://yoursite.com/tags/select/"},{"name":"poll","slug":"poll","permalink":"http://yoursite.com/tags/poll/"},{"name":"epoll","slug":"epoll","permalink":"http://yoursite.com/tags/epoll/"},{"name":"多线程","slug":"多线程","permalink":"http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"Linux，多进程","slug":"Linux，多进程","permalink":"http://yoursite.com/tags/Linux%EF%BC%8C%E5%A4%9A%E8%BF%9B%E7%A8%8B/"},{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"指针","slug":"指针","permalink":"http://yoursite.com/tags/%E6%8C%87%E9%92%88/"},{"name":"智能指针","slug":"智能指针","permalink":"http://yoursite.com/tags/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"},{"name":"类","slug":"类","permalink":"http://yoursite.com/tags/%E7%B1%BB/"},{"name":"虚函数","slug":"虚函数","permalink":"http://yoursite.com/tags/%E8%99%9A%E5%87%BD%E6%95%B0/"},{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"},{"name":"const","slug":"const","permalink":"http://yoursite.com/tags/const/"},{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/tags/algorithm/"},{"name":"vim","slug":"vim","permalink":"http://yoursite.com/tags/vim/"}]}