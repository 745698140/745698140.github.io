{"meta":{"title":"MoChen's","subtitle":"","description":"临渊羡鱼，不如退而结网","author":"MoChen","url":"http://yoursite.com","root":"/"},"pages":[{"title":"tags","date":"2020-08-23T14:01:22.000Z","updated":"2020-08-23T14:09:32.600Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"算法中的差分思想","slug":"算法中的差分思想","date":"2020-09-21T14:48:59.000Z","updated":"2020-09-21T14:48:59.343Z","comments":true,"path":"2020/09/21/算法中的差分思想/","link":"","permalink":"http://yoursite.com/2020/09/21/%E7%AE%97%E6%B3%95%E4%B8%AD%E7%9A%84%E5%B7%AE%E5%88%86%E6%80%9D%E6%83%B3/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"C++中的const成员函数","slug":"C++中的const成员函数","date":"2020-09-21T14:43:13.000Z","updated":"2020-10-01T11:18:08.673Z","comments":true,"path":"2020/09/21/C++中的const成员函数/","link":"","permalink":"http://yoursite.com/2020/09/21/C++%E4%B8%AD%E7%9A%84const%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/","excerpt":"我们在定义类的成员函数的时候，往往函数块内会返回一个其他的成员，这种方式实际上是隐式地指向调用该函数的对象的成员，即成员函数通过一个名为this的额外的隐式参数来访问调用它的那个对象。 而我们往往会看到成员函数的参数列表后紧跟着一个const关键字，这个const的作用是修改隐式this指针的类型。","text":"我们在定义类的成员函数的时候，往往函数块内会返回一个其他的成员，这种方式实际上是隐式地指向调用该函数的对象的成员，即成员函数通过一个名为this的额外的隐式参数来访问调用它的那个对象。 而我们往往会看到成员函数的参数列表后紧跟着一个const关键字，这个const的作用是修改隐式this指针的类型。 默认情况下来说，this的类型是指向类类型的非常量版本的指针，可以表示为 struct_name *const, 尽管this是隐式的，但它仍需要遵循初始化原则，这就意味值默认情况下this指针是不能绑定到一个常量对象上的，这也就意味着我们不能在一个常量对象上调用普通成员函数。 123456789101112131415161718// 简单定义一个类struct help&#123; int a; int b; help(int aa, int bb) &#123; a = aa; b = bb; &#125; int helper() &#123; return a; &#125;&#125;;int main(int argc, const char * argv[]) &#123; const help temp(12, 23); // 声明一个常量类对象 int c = temp.helper(); // 错误，因为help()是一个普通成员函数，所以this是指向一个非常量对象，而temp又是一个常量对象，所以会报错 cout &lt;&lt; c &lt;&lt; endl;&#125; 所以在这种情况下，我们应该把this声明为 const struct_name *const 这样就可以解决问题，但又因为this是隐式的，所以我们可以将成员函数的声明改为： 1int helper() const &#123;&#125; 这样就可以将this声明为指向常量对象的版本了。而这种使用const的成员函数也叫做常量成员函数(const member function)。","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"C++中的顶层const和底层const","slug":"C++中的顶层const和底层const","date":"2020-09-01T10:40:27.000Z","updated":"2020-09-21T14:52:36.222Z","comments":true,"path":"2020/09/01/C++中的顶层const和底层const/","link":"","permalink":"http://yoursite.com/2020/09/01/C++%E4%B8%AD%E7%9A%84%E9%A1%B6%E5%B1%82const%E5%92%8C%E5%BA%95%E5%B1%82const/","excerpt":"​ const对象一旦创建后其值就不能再改变。而对于指针这种本身是一个对象，它又可以指向另一个对象的情况时，指针本身是不是常量以及指针所指的是不是一个常量就是两个相互独立的问题了，用名词顶层const(top-level const)表示指针本身是个常量，而用底层const(low-level const)表示指针所指的对象是一个常量。","text":"​ const对象一旦创建后其值就不能再改变。而对于指针这种本身是一个对象，它又可以指向另一个对象的情况时，指针本身是不是常量以及指针所指的是不是一个常量就是两个相互独立的问题了，用名词顶层const(top-level const)表示指针本身是个常量，而用底层const(low-level const)表示指针所指的对象是一个常量。 top-level const 的一些演示1234567//初始化两个非常量int i1 = 20; int i2 = 30;//初始化一个顶层const指针，这个操作意味着指针本身的值是一个常量，其本身是不可以改变的，而指针所指的值是一个非常量是可以改变的int *const p = &amp;i1;p = &amp;i2; //错误。指针p本身是一个常量，是不可以改变的*p = i2; //正确。指针所指的值并不是一个常量，是可以改变的 low-level const 的一些演示1234567//初始化两个非常量int i1 = 20;int i2 = 30;//初始化一个底层const指针，这个操作意味着这个指针指向一个常量，不可以通过该指针去改变指针所指的对象，但指针本身是可以更改的const int *p = &amp;i1;*p = i2; //错误。指针p所指的是一个常量，不可以通过指针去修改其指向的对象p = &amp;i2; //正确。指针本身不是常量，可以修改指针本身 ​ 上面的展示应该很清楚地展示了顶层const和底层const的区别所在，当然我们也可以将一个指针声明为既是底层cosnt亦是顶层const，这样我们就不可以通过指针去修改指针所指的对象，也不可以修改指针本身，其声明方式如下。 1234567//初始化两个非常量int i1 = 20;int i2 = 30;//初始化一个既是底层const也是顶层const的指针const int *const p = &amp;i1;*p = i2; //错误。指针p是一个底层const，其所指的对象是一个常量。p = &amp;i2; //错误。指针p是一个顶层const，其本身是一个常量。 所谓的指向常量的指针(pointer to const)只是指针自己以为自己指向的是常量​ 为什么上面的例子都是初始化两个非常量呢？因为其实对于指向常量的指针来说（意思是底层const），只是指针自以为自己指向的是一个常量，所以指针自觉地不去改变所指的对象。但其实指向常量的指针没有规定其所指的对象必须是一个常量。 12345678//初始化两个非常量int i1 = 20;int i2 = 30;//初始化一个底层const指针，即指向常量的指针const int *p = &amp;i1;*p = i2; //错误。指针认为自己指向的是常量，不能通过自己去改变所指的对象i1 = i2; //正确。指向常量的指针没有规定所指的对象是一个常量，所以可以直接修改非常量对象本身std::cout &lt;&lt; *p; //将会打印&quot;30&quot;，而不是&quot;20&quot; 指针和constexpr​ C++11中，允许将变量声明为constexpr类型以便由编译器来验证变量的值是否是一个常量表达式。但必须明确一点，在constexpr声明中如果定义了一个指针，限定符constexpr仅对指针有效，与指针所指的对象无关。意思就是通过constexpr定义的指针是一个顶层const。 1234constexpr int i = 20; //定义一个常量int j = 100; //定义一个非常量constexpr int *p = &amp;i; //错误。p本身是一个常量，但p所指的不是一个常量，所以p不能指向一个常量整数constexpr int *p = &amp;j; //正确。p本身是一个常量指针，指向一个整数","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"指针","slug":"指针","permalink":"http://yoursite.com/tags/%E6%8C%87%E9%92%88/"},{"name":"const","slug":"const","permalink":"http://yoursite.com/tags/const/"}]},{"title":"对KMP算法的一些理解","slug":"对KMP算法的一些理解","date":"2020-08-24T01:14:10.000Z","updated":"2020-08-29T13:07:55.033Z","comments":true,"path":"2020/08/24/对KMP算法的一些理解/","link":"","permalink":"http://yoursite.com/2020/08/24/%E5%AF%B9KMP%E7%AE%97%E6%B3%95%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/","excerpt":"KMP算法是一种字符串匹配算法，可以在O(n+m)时间复杂度内实现两个字符串的匹配。","text":"KMP算法是一种字符串匹配算法，可以在O(n+m)时间复杂度内实现两个字符串的匹配。 关于字符串匹配暴力解决字符串匹配即通过两个串的每个字符逐一比较，python实现如下： 1234def match(S, P): for i in range(len(S) - len(P) + 1): if S[i:i+len(P)] == P: return i 如果 n = len(S), m = len(P)。那么最坏的情况下，暴力解法的时间复杂度能去到O(nm)。 暴力解法并没有利用字符串匹配过程中残留的一部分信息，而KMP算法则是通过“尽可能减少比较的趟数”来做到优化，即看看能否在匹配失败后，跳过一部分不可能成功的字符串比较来使复杂度降低。 简述KMP起始思路","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/tags/algorithm/"}]},{"title":"vimKeyboard","slug":"vimKeyboard","date":"2020-08-23T13:19:30.000Z","updated":"2020-08-23T13:19:30.000Z","comments":true,"path":"2020/08/23/vimKeyboard/","link":"","permalink":"http://yoursite.com/2020/08/23/vimKeyboard/","excerpt":"","text":"vim键位图","categories":[],"tags":[{"name":"vim","slug":"vim","permalink":"http://yoursite.com/tags/vim/"}]}],"categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"指针","slug":"指针","permalink":"http://yoursite.com/tags/%E6%8C%87%E9%92%88/"},{"name":"const","slug":"const","permalink":"http://yoursite.com/tags/const/"},{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/tags/algorithm/"},{"name":"vim","slug":"vim","permalink":"http://yoursite.com/tags/vim/"}]}